// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: game.proto

/*
	Package protoMsg is a generated protocol buffer package.

	It is generated from these files:
		game.proto

	It has these top-level messages:
		UserMainDataNotify
		Vector3
		PlayerRegister
		PlayerLogin
		PlayerLogout
		MailObject
		MailInfo
		ReqGetMailList
		RetMailList
		ReqMailInfo
		RetMailInfo
		DelMail
		GetMailObj
		AnnuonceInfo
		InitAnnuonceInfoRet
		FriendInfo
		PlatFriendStateReq
		PlatFriendState
		PlatFriendStateRet
		FriendRankInfo
		SyncFriendList
		FriendApplyInfo
		SyncFriendApplyList
		DoSendItemReq
		GameSvrState
		OwnGoodsItem
		OwnGoodsInfo
		RectInfo
		CreateSpaceReq
		CreateSpaceRet
		ReportCellLoad
		CellInfoReq
		CellInfoRet
		CellBorderChangeNotify
		CellInfoNotify
		CreateCellNotify
		DeleteCellNotify
		SkillEffect
		AttackReq
		MoveReq
		MoveUpdate
		DetectCell
		EnterCellOk
		EffectNotify
*/
package protoMsg

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type EffectType int32

const (
	EffectType_Damage        EffectType = 0
	EffectType_RecoverHp     EffectType = 1
	EffectType_ReduceDefence EffectType = 2
	EffectType_AddDefence    EffectType = 3
)

var EffectType_name = map[int32]string{
	0: "Damage",
	1: "RecoverHp",
	2: "ReduceDefence",
	3: "AddDefence",
}
var EffectType_value = map[string]int32{
	"Damage":        0,
	"RecoverHp":     1,
	"ReduceDefence": 2,
	"AddDefence":    3,
}

func (x EffectType) String() string {
	return proto.EnumName(EffectType_name, int32(x))
}
func (EffectType) EnumDescriptor() ([]byte, []int) { return fileDescriptorGame, []int{0} }

// s-->c 玩家主数据
type UserMainDataNotify struct {
	Uid   uint64 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Name_ string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Coins uint64 `protobuf:"varint,3,opt,name=coins,proto3" json:"coins,omitempty"`
	Diams uint64 `protobuf:"varint,4,opt,name=diams,proto3" json:"diams,omitempty"`
}

func (m *UserMainDataNotify) Reset()                    { *m = UserMainDataNotify{} }
func (m *UserMainDataNotify) String() string            { return proto.CompactTextString(m) }
func (*UserMainDataNotify) ProtoMessage()               {}
func (*UserMainDataNotify) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{0} }

func (m *UserMainDataNotify) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UserMainDataNotify) GetName_() string {
	if m != nil {
		return m.Name_
	}
	return ""
}

func (m *UserMainDataNotify) GetCoins() uint64 {
	if m != nil {
		return m.Coins
	}
	return 0
}

func (m *UserMainDataNotify) GetDiams() uint64 {
	if m != nil {
		return m.Diams
	}
	return 0
}

// 坐标
type Vector3 struct {
	X float32 `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y float32 `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z float32 `protobuf:"fixed32,3,opt,name=z,proto3" json:"z,omitempty"`
}

func (m *Vector3) Reset()                    { *m = Vector3{} }
func (m *Vector3) String() string            { return proto.CompactTextString(m) }
func (*Vector3) ProtoMessage()               {}
func (*Vector3) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{1} }

func (m *Vector3) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Vector3) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Vector3) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

// TLog 玩家注册消息
type PlayerRegister struct {
	GameSvrID    string `protobuf:"bytes,1,opt,name=GameSvrID,proto3" json:"GameSvrID,omitempty"`
	DtEventTime  string `protobuf:"bytes,2,opt,name=DtEventTime,proto3" json:"DtEventTime,omitempty"`
	VGameAppID   string `protobuf:"bytes,3,opt,name=VGameAppID,proto3" json:"VGameAppID,omitempty"`
	PlatID       uint32 `protobuf:"varint,4,opt,name=PlatID,proto3" json:"PlatID,omitempty"`
	IZoneAreaID  uint32 `protobuf:"varint,5,opt,name=IZoneAreaID,proto3" json:"IZoneAreaID,omitempty"`
	VOpenID      string `protobuf:"bytes,6,opt,name=VOpenID,proto3" json:"VOpenID,omitempty"`
	TelecomOper  string `protobuf:"bytes,7,opt,name=TelecomOper,proto3" json:"TelecomOper,omitempty"`
	RegChannel   string `protobuf:"bytes,8,opt,name=RegChannel,proto3" json:"RegChannel,omitempty"`
	LoginChannel uint32 `protobuf:"varint,9,opt,name=LoginChannel,proto3" json:"LoginChannel,omitempty"`
}

func (m *PlayerRegister) Reset()                    { *m = PlayerRegister{} }
func (m *PlayerRegister) String() string            { return proto.CompactTextString(m) }
func (*PlayerRegister) ProtoMessage()               {}
func (*PlayerRegister) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{2} }

func (m *PlayerRegister) GetGameSvrID() string {
	if m != nil {
		return m.GameSvrID
	}
	return ""
}

func (m *PlayerRegister) GetDtEventTime() string {
	if m != nil {
		return m.DtEventTime
	}
	return ""
}

func (m *PlayerRegister) GetVGameAppID() string {
	if m != nil {
		return m.VGameAppID
	}
	return ""
}

func (m *PlayerRegister) GetPlatID() uint32 {
	if m != nil {
		return m.PlatID
	}
	return 0
}

func (m *PlayerRegister) GetIZoneAreaID() uint32 {
	if m != nil {
		return m.IZoneAreaID
	}
	return 0
}

func (m *PlayerRegister) GetVOpenID() string {
	if m != nil {
		return m.VOpenID
	}
	return ""
}

func (m *PlayerRegister) GetTelecomOper() string {
	if m != nil {
		return m.TelecomOper
	}
	return ""
}

func (m *PlayerRegister) GetRegChannel() string {
	if m != nil {
		return m.RegChannel
	}
	return ""
}

func (m *PlayerRegister) GetLoginChannel() uint32 {
	if m != nil {
		return m.LoginChannel
	}
	return 0
}

// TLog 玩家登录消息
type PlayerLogin struct {
	GameSvrID        string `protobuf:"bytes,1,opt,name=GameSvrID,proto3" json:"GameSvrID,omitempty"`
	DtEventTime      string `protobuf:"bytes,2,opt,name=DtEventTime,proto3" json:"DtEventTime,omitempty"`
	VGameAppID       string `protobuf:"bytes,3,opt,name=VGameAppID,proto3" json:"VGameAppID,omitempty"`
	PlatID           uint32 `protobuf:"varint,4,opt,name=PlatID,proto3" json:"PlatID,omitempty"`
	IZoneAreaID      uint32 `protobuf:"varint,5,opt,name=IZoneAreaID,proto3" json:"IZoneAreaID,omitempty"`
	VOpenID          string `protobuf:"bytes,6,opt,name=VOpenID,proto3" json:"VOpenID,omitempty"`
	Level            uint32 `protobuf:"varint,7,opt,name=Level,proto3" json:"Level,omitempty"`
	PlayerFriendsNum uint32 `protobuf:"varint,8,opt,name=PlayerFriendsNum,proto3" json:"PlayerFriendsNum,omitempty"`
	ClientVersion    string `protobuf:"bytes,9,opt,name=ClientVersion,proto3" json:"ClientVersion,omitempty"`
	SystemHardware   string `protobuf:"bytes,10,opt,name=SystemHardware,proto3" json:"SystemHardware,omitempty"`
	TelecomOper      string `protobuf:"bytes,11,opt,name=TelecomOper,proto3" json:"TelecomOper,omitempty"`
	Network          string `protobuf:"bytes,12,opt,name=Network,proto3" json:"Network,omitempty"`
	LoginChannel     uint32 `protobuf:"varint,13,opt,name=LoginChannel,proto3" json:"LoginChannel,omitempty"`
	VRoleID          string `protobuf:"bytes,14,opt,name=VRoleID,proto3" json:"VRoleID,omitempty"`
	VRoleName        string `protobuf:"bytes,15,opt,name=VRoleName,proto3" json:"VRoleName,omitempty"`
	RegChannel       string `protobuf:"bytes,16,opt,name=RegChannel,proto3" json:"RegChannel,omitempty"`
}

func (m *PlayerLogin) Reset()                    { *m = PlayerLogin{} }
func (m *PlayerLogin) String() string            { return proto.CompactTextString(m) }
func (*PlayerLogin) ProtoMessage()               {}
func (*PlayerLogin) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{3} }

func (m *PlayerLogin) GetGameSvrID() string {
	if m != nil {
		return m.GameSvrID
	}
	return ""
}

func (m *PlayerLogin) GetDtEventTime() string {
	if m != nil {
		return m.DtEventTime
	}
	return ""
}

func (m *PlayerLogin) GetVGameAppID() string {
	if m != nil {
		return m.VGameAppID
	}
	return ""
}

func (m *PlayerLogin) GetPlatID() uint32 {
	if m != nil {
		return m.PlatID
	}
	return 0
}

func (m *PlayerLogin) GetIZoneAreaID() uint32 {
	if m != nil {
		return m.IZoneAreaID
	}
	return 0
}

func (m *PlayerLogin) GetVOpenID() string {
	if m != nil {
		return m.VOpenID
	}
	return ""
}

func (m *PlayerLogin) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *PlayerLogin) GetPlayerFriendsNum() uint32 {
	if m != nil {
		return m.PlayerFriendsNum
	}
	return 0
}

func (m *PlayerLogin) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

func (m *PlayerLogin) GetSystemHardware() string {
	if m != nil {
		return m.SystemHardware
	}
	return ""
}

func (m *PlayerLogin) GetTelecomOper() string {
	if m != nil {
		return m.TelecomOper
	}
	return ""
}

func (m *PlayerLogin) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

func (m *PlayerLogin) GetLoginChannel() uint32 {
	if m != nil {
		return m.LoginChannel
	}
	return 0
}

func (m *PlayerLogin) GetVRoleID() string {
	if m != nil {
		return m.VRoleID
	}
	return ""
}

func (m *PlayerLogin) GetVRoleName() string {
	if m != nil {
		return m.VRoleName
	}
	return ""
}

func (m *PlayerLogin) GetRegChannel() string {
	if m != nil {
		return m.RegChannel
	}
	return ""
}

// TLog 玩家登出消息
type PlayerLogout struct {
	GameSvrID        string `protobuf:"bytes,1,opt,name=GameSvrID,proto3" json:"GameSvrID,omitempty"`
	DtEventTime      string `protobuf:"bytes,2,opt,name=DtEventTime,proto3" json:"DtEventTime,omitempty"`
	VGameAppID       string `protobuf:"bytes,3,opt,name=VGameAppID,proto3" json:"VGameAppID,omitempty"`
	PlatID           uint32 `protobuf:"varint,4,opt,name=PlatID,proto3" json:"PlatID,omitempty"`
	IZoneAreaID      uint32 `protobuf:"varint,5,opt,name=IZoneAreaID,proto3" json:"IZoneAreaID,omitempty"`
	VOpenID          string `protobuf:"bytes,6,opt,name=VOpenID,proto3" json:"VOpenID,omitempty"`
	OnlineTime       uint32 `protobuf:"varint,7,opt,name=OnlineTime,proto3" json:"OnlineTime,omitempty"`
	Level            uint32 `protobuf:"varint,8,opt,name=Level,proto3" json:"Level,omitempty"`
	PlayerFriendsNum uint32 `protobuf:"varint,9,opt,name=PlayerFriendsNum,proto3" json:"PlayerFriendsNum,omitempty"`
	ClientVersion    string `protobuf:"bytes,10,opt,name=ClientVersion,proto3" json:"ClientVersion,omitempty"`
	SystemHardware   string `protobuf:"bytes,11,opt,name=SystemHardware,proto3" json:"SystemHardware,omitempty"`
	TelecomOper      string `protobuf:"bytes,12,opt,name=TelecomOper,proto3" json:"TelecomOper,omitempty"`
	Network          string `protobuf:"bytes,13,opt,name=Network,proto3" json:"Network,omitempty"`
}

func (m *PlayerLogout) Reset()                    { *m = PlayerLogout{} }
func (m *PlayerLogout) String() string            { return proto.CompactTextString(m) }
func (*PlayerLogout) ProtoMessage()               {}
func (*PlayerLogout) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{4} }

func (m *PlayerLogout) GetGameSvrID() string {
	if m != nil {
		return m.GameSvrID
	}
	return ""
}

func (m *PlayerLogout) GetDtEventTime() string {
	if m != nil {
		return m.DtEventTime
	}
	return ""
}

func (m *PlayerLogout) GetVGameAppID() string {
	if m != nil {
		return m.VGameAppID
	}
	return ""
}

func (m *PlayerLogout) GetPlatID() uint32 {
	if m != nil {
		return m.PlatID
	}
	return 0
}

func (m *PlayerLogout) GetIZoneAreaID() uint32 {
	if m != nil {
		return m.IZoneAreaID
	}
	return 0
}

func (m *PlayerLogout) GetVOpenID() string {
	if m != nil {
		return m.VOpenID
	}
	return ""
}

func (m *PlayerLogout) GetOnlineTime() uint32 {
	if m != nil {
		return m.OnlineTime
	}
	return 0
}

func (m *PlayerLogout) GetLevel() uint32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *PlayerLogout) GetPlayerFriendsNum() uint32 {
	if m != nil {
		return m.PlayerFriendsNum
	}
	return 0
}

func (m *PlayerLogout) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

func (m *PlayerLogout) GetSystemHardware() string {
	if m != nil {
		return m.SystemHardware
	}
	return ""
}

func (m *PlayerLogout) GetTelecomOper() string {
	if m != nil {
		return m.TelecomOper
	}
	return ""
}

func (m *PlayerLogout) GetNetwork() string {
	if m != nil {
		return m.Network
	}
	return ""
}

type MailObject struct {
	Id  uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Num uint32 `protobuf:"varint,2,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *MailObject) Reset()                    { *m = MailObject{} }
func (m *MailObject) String() string            { return proto.CompactTextString(m) }
func (*MailObject) ProtoMessage()               {}
func (*MailObject) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{5} }

func (m *MailObject) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MailObject) GetNum() uint32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type MailInfo struct {
	Mailid   uint64        `protobuf:"varint,1,opt,name=mailid,proto3" json:"mailid,omitempty"`
	Mailtype uint32        `protobuf:"varint,2,opt,name=mailtype,proto3" json:"mailtype,omitempty"`
	Gettime  uint64        `protobuf:"varint,3,opt,name=gettime,proto3" json:"gettime,omitempty"`
	Haveread bool          `protobuf:"varint,4,opt,name=haveread,proto3" json:"haveread,omitempty"`
	Title    string        `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	Text     string        `protobuf:"bytes,6,opt,name=text,proto3" json:"text,omitempty"`
	Url      string        `protobuf:"bytes,7,opt,name=url,proto3" json:"url,omitempty"`
	Objs     []*MailObject `protobuf:"bytes,8,rep,name=objs" json:"objs,omitempty"`
	Haveget  bool          `protobuf:"varint,9,opt,name=haveget,proto3" json:"haveget,omitempty"`
	Button   string        `protobuf:"bytes,10,opt,name=button,proto3" json:"button,omitempty"`
}

func (m *MailInfo) Reset()                    { *m = MailInfo{} }
func (m *MailInfo) String() string            { return proto.CompactTextString(m) }
func (*MailInfo) ProtoMessage()               {}
func (*MailInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{6} }

func (m *MailInfo) GetMailid() uint64 {
	if m != nil {
		return m.Mailid
	}
	return 0
}

func (m *MailInfo) GetMailtype() uint32 {
	if m != nil {
		return m.Mailtype
	}
	return 0
}

func (m *MailInfo) GetGettime() uint64 {
	if m != nil {
		return m.Gettime
	}
	return 0
}

func (m *MailInfo) GetHaveread() bool {
	if m != nil {
		return m.Haveread
	}
	return false
}

func (m *MailInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MailInfo) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *MailInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *MailInfo) GetObjs() []*MailObject {
	if m != nil {
		return m.Objs
	}
	return nil
}

func (m *MailInfo) GetHaveget() bool {
	if m != nil {
		return m.Haveget
	}
	return false
}

func (m *MailInfo) GetButton() string {
	if m != nil {
		return m.Button
	}
	return ""
}

// 获取邮件列表
type ReqGetMailList struct {
}

func (m *ReqGetMailList) Reset()                    { *m = ReqGetMailList{} }
func (m *ReqGetMailList) String() string            { return proto.CompactTextString(m) }
func (*ReqGetMailList) ProtoMessage()               {}
func (*ReqGetMailList) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{7} }

// 返回邮件列表
type RetMailList struct {
	Mails []*MailInfo `protobuf:"bytes,1,rep,name=mails" json:"mails,omitempty"`
}

func (m *RetMailList) Reset()                    { *m = RetMailList{} }
func (m *RetMailList) String() string            { return proto.CompactTextString(m) }
func (*RetMailList) ProtoMessage()               {}
func (*RetMailList) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{8} }

func (m *RetMailList) GetMails() []*MailInfo {
	if m != nil {
		return m.Mails
	}
	return nil
}

// 查看邮件
type ReqMailInfo struct {
	Mailid uint64 `protobuf:"varint,1,opt,name=mailid,proto3" json:"mailid,omitempty"`
}

func (m *ReqMailInfo) Reset()                    { *m = ReqMailInfo{} }
func (m *ReqMailInfo) String() string            { return proto.CompactTextString(m) }
func (*ReqMailInfo) ProtoMessage()               {}
func (*ReqMailInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{9} }

func (m *ReqMailInfo) GetMailid() uint64 {
	if m != nil {
		return m.Mailid
	}
	return 0
}

// 返回邮件信息
type RetMailInfo struct {
	Mail *MailInfo `protobuf:"bytes,1,opt,name=mail" json:"mail,omitempty"`
}

func (m *RetMailInfo) Reset()                    { *m = RetMailInfo{} }
func (m *RetMailInfo) String() string            { return proto.CompactTextString(m) }
func (*RetMailInfo) ProtoMessage()               {}
func (*RetMailInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{10} }

func (m *RetMailInfo) GetMail() *MailInfo {
	if m != nil {
		return m.Mail
	}
	return nil
}

// 删除邮件 (返回RetMailList)
type DelMail struct {
	Mailid []uint64 `protobuf:"varint,1,rep,packed,name=mailid" json:"mailid,omitempty"`
}

func (m *DelMail) Reset()                    { *m = DelMail{} }
func (m *DelMail) String() string            { return proto.CompactTextString(m) }
func (*DelMail) ProtoMessage()               {}
func (*DelMail) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{11} }

func (m *DelMail) GetMailid() []uint64 {
	if m != nil {
		return m.Mailid
	}
	return nil
}

// 领取附件 (返回RetMailInfo)
type GetMailObj struct {
	Mailid uint64 `protobuf:"varint,1,opt,name=mailid,proto3" json:"mailid,omitempty"`
}

func (m *GetMailObj) Reset()                    { *m = GetMailObj{} }
func (m *GetMailObj) String() string            { return proto.CompactTextString(m) }
func (*GetMailObj) ProtoMessage()               {}
func (*GetMailObj) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{12} }

func (m *GetMailObj) GetMailid() uint64 {
	if m != nil {
		return m.Mailid
	}
	return 0
}

// 公告信息
type AnnuonceInfo struct {
	Id           uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StartTime    int64  `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime      int64  `protobuf:"varint,3,opt,name=endTime,proto3" json:"endTime,omitempty"`
	InternalTime int64  `protobuf:"varint,4,opt,name=internalTime,proto3" json:"internalTime,omitempty"`
	Content      string `protobuf:"bytes,5,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *AnnuonceInfo) Reset()                    { *m = AnnuonceInfo{} }
func (m *AnnuonceInfo) String() string            { return proto.CompactTextString(m) }
func (*AnnuonceInfo) ProtoMessage()               {}
func (*AnnuonceInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{13} }

func (m *AnnuonceInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *AnnuonceInfo) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *AnnuonceInfo) GetEndTime() int64 {
	if m != nil {
		return m.EndTime
	}
	return 0
}

func (m *AnnuonceInfo) GetInternalTime() int64 {
	if m != nil {
		return m.InternalTime
	}
	return 0
}

func (m *AnnuonceInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// s-->c 初始化公告信息
type InitAnnuonceInfoRet struct {
	Item []*AnnuonceInfo `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
}

func (m *InitAnnuonceInfoRet) Reset()                    { *m = InitAnnuonceInfoRet{} }
func (m *InitAnnuonceInfoRet) String() string            { return proto.CompactTextString(m) }
func (*InitAnnuonceInfoRet) ProtoMessage()               {}
func (*InitAnnuonceInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{14} }

func (m *InitAnnuonceInfoRet) GetItem() []*AnnuonceInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

// 好友信息
type FriendInfo struct {
	Id        uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name_     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	State     uint32 `protobuf:"varint,3,opt,name=state,proto3" json:"state,omitempty"`
	Time      uint32 `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	Url       string `protobuf:"bytes,5,opt,name=url,proto3" json:"url,omitempty"`
	Enterplat string `protobuf:"bytes,6,opt,name=enterplat,proto3" json:"enterplat,omitempty"`
	Qqvip     uint32 `protobuf:"varint,7,opt,name=qqvip,proto3" json:"qqvip,omitempty"`
	Nickname  string `protobuf:"bytes,8,opt,name=nickname,proto3" json:"nickname,omitempty"`
}

func (m *FriendInfo) Reset()                    { *m = FriendInfo{} }
func (m *FriendInfo) String() string            { return proto.CompactTextString(m) }
func (*FriendInfo) ProtoMessage()               {}
func (*FriendInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{15} }

func (m *FriendInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FriendInfo) GetName_() string {
	if m != nil {
		return m.Name_
	}
	return ""
}

func (m *FriendInfo) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *FriendInfo) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *FriendInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *FriendInfo) GetEnterplat() string {
	if m != nil {
		return m.Enterplat
	}
	return ""
}

func (m *FriendInfo) GetQqvip() uint32 {
	if m != nil {
		return m.Qqvip
	}
	return 0
}

func (m *FriendInfo) GetNickname() string {
	if m != nil {
		return m.Nickname
	}
	return ""
}

// c-->s 请求平台好友状态
type PlatFriendStateReq struct {
	Openid []string `protobuf:"bytes,1,rep,name=openid" json:"openid,omitempty"`
}

func (m *PlatFriendStateReq) Reset()                    { *m = PlatFriendStateReq{} }
func (m *PlatFriendStateReq) String() string            { return proto.CompactTextString(m) }
func (*PlatFriendStateReq) ProtoMessage()               {}
func (*PlatFriendStateReq) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{16} }

func (m *PlatFriendStateReq) GetOpenid() []string {
	if m != nil {
		return m.Openid
	}
	return nil
}

type PlatFriendState struct {
	Openid string `protobuf:"bytes,1,opt,name=openid,proto3" json:"openid,omitempty"`
	Uid    uint64 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	State  uint32 `protobuf:"varint,3,opt,name=state,proto3" json:"state,omitempty"`
	Time   uint32 `protobuf:"varint,4,opt,name=time,proto3" json:"time,omitempty"`
	Name_  string `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PlatFriendState) Reset()                    { *m = PlatFriendState{} }
func (m *PlatFriendState) String() string            { return proto.CompactTextString(m) }
func (*PlatFriendState) ProtoMessage()               {}
func (*PlatFriendState) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{17} }

func (m *PlatFriendState) GetOpenid() string {
	if m != nil {
		return m.Openid
	}
	return ""
}

func (m *PlatFriendState) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *PlatFriendState) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *PlatFriendState) GetTime() uint32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *PlatFriendState) GetName_() string {
	if m != nil {
		return m.Name_
	}
	return ""
}

type PlatFriendStateRet struct {
	Data []*PlatFriendState `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
}

func (m *PlatFriendStateRet) Reset()                    { *m = PlatFriendStateRet{} }
func (m *PlatFriendStateRet) String() string            { return proto.CompactTextString(m) }
func (*PlatFriendStateRet) ProtoMessage()               {}
func (*PlatFriendStateRet) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{18} }

func (m *PlatFriendStateRet) GetData() []*PlatFriendState {
	if m != nil {
		return m.Data
	}
	return nil
}

// 好友排名信息
type FriendRankInfo struct {
	Uid         uint64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Name_       string  `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Url         string  `protobuf:"bytes,3,opt,name=Url,proto3" json:"Url,omitempty"`
	SoloRating  float32 `protobuf:"fixed32,4,opt,name=SoloRating,proto3" json:"SoloRating,omitempty"`
	DuoRating   float32 `protobuf:"fixed32,5,opt,name=DuoRating,proto3" json:"DuoRating,omitempty"`
	SquadRating float32 `protobuf:"fixed32,6,opt,name=SquadRating,proto3" json:"SquadRating,omitempty"`
	QqVip       uint32  `protobuf:"varint,7,opt,name=QqVip,proto3" json:"QqVip,omitempty"`
	GameEenter  string  `protobuf:"bytes,8,opt,name=GameEenter,proto3" json:"GameEenter,omitempty"`
}

func (m *FriendRankInfo) Reset()                    { *m = FriendRankInfo{} }
func (m *FriendRankInfo) String() string            { return proto.CompactTextString(m) }
func (*FriendRankInfo) ProtoMessage()               {}
func (*FriendRankInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{19} }

func (m *FriendRankInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *FriendRankInfo) GetName_() string {
	if m != nil {
		return m.Name_
	}
	return ""
}

func (m *FriendRankInfo) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *FriendRankInfo) GetSoloRating() float32 {
	if m != nil {
		return m.SoloRating
	}
	return 0
}

func (m *FriendRankInfo) GetDuoRating() float32 {
	if m != nil {
		return m.DuoRating
	}
	return 0
}

func (m *FriendRankInfo) GetSquadRating() float32 {
	if m != nil {
		return m.SquadRating
	}
	return 0
}

func (m *FriendRankInfo) GetQqVip() uint32 {
	if m != nil {
		return m.QqVip
	}
	return 0
}

func (m *FriendRankInfo) GetGameEenter() string {
	if m != nil {
		return m.GameEenter
	}
	return ""
}

// s-->c 同步好友信息列表
type SyncFriendList struct {
	Item []*FriendInfo `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
}

func (m *SyncFriendList) Reset()                    { *m = SyncFriendList{} }
func (m *SyncFriendList) String() string            { return proto.CompactTextString(m) }
func (*SyncFriendList) ProtoMessage()               {}
func (*SyncFriendList) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{20} }

func (m *SyncFriendList) GetItem() []*FriendInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

// 好友申请列表信息
type FriendApplyInfo struct {
	Id        uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name_     string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ApplyTime int64  `protobuf:"varint,3,opt,name=applyTime,proto3" json:"applyTime,omitempty"`
}

func (m *FriendApplyInfo) Reset()                    { *m = FriendApplyInfo{} }
func (m *FriendApplyInfo) String() string            { return proto.CompactTextString(m) }
func (*FriendApplyInfo) ProtoMessage()               {}
func (*FriendApplyInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{21} }

func (m *FriendApplyInfo) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *FriendApplyInfo) GetName_() string {
	if m != nil {
		return m.Name_
	}
	return ""
}

func (m *FriendApplyInfo) GetApplyTime() int64 {
	if m != nil {
		return m.ApplyTime
	}
	return 0
}

// s-->c 同步好友申请列表信息
type SyncFriendApplyList struct {
	Item []*FriendApplyInfo `protobuf:"bytes,1,rep,name=item" json:"item,omitempty"`
}

func (m *SyncFriendApplyList) Reset()                    { *m = SyncFriendApplyList{} }
func (m *SyncFriendApplyList) String() string            { return proto.CompactTextString(m) }
func (*SyncFriendApplyList) ProtoMessage()               {}
func (*SyncFriendApplyList) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{22} }

func (m *SyncFriendApplyList) GetItem() []*FriendApplyInfo {
	if m != nil {
		return m.Item
	}
	return nil
}

type DoSendItemReq struct {
	Title   string        `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	Content string        `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	Objs    []*MailObject `protobuf:"bytes,3,rep,name=objs" json:"objs,omitempty"`
	Url     string        `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *DoSendItemReq) Reset()                    { *m = DoSendItemReq{} }
func (m *DoSendItemReq) String() string            { return proto.CompactTextString(m) }
func (*DoSendItemReq) ProtoMessage()               {}
func (*DoSendItemReq) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{23} }

func (m *DoSendItemReq) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *DoSendItemReq) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *DoSendItemReq) GetObjs() []*MailObject {
	if m != nil {
		return m.Objs
	}
	return nil
}

func (m *DoSendItemReq) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// GameSvrState 服务器状态日志
type GameSvrState struct {
	DtEventTime string `protobuf:"bytes,1,opt,name=DtEventTime,proto3" json:"DtEventTime,omitempty"`
	VGameIP     string `protobuf:"bytes,2,opt,name=VGameIP,proto3" json:"VGameIP,omitempty"`
	IZoneAreaID uint32 `protobuf:"varint,3,opt,name=IZoneAreaID,proto3" json:"IZoneAreaID,omitempty"`
}

func (m *GameSvrState) Reset()                    { *m = GameSvrState{} }
func (m *GameSvrState) String() string            { return proto.CompactTextString(m) }
func (*GameSvrState) ProtoMessage()               {}
func (*GameSvrState) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{24} }

func (m *GameSvrState) GetDtEventTime() string {
	if m != nil {
		return m.DtEventTime
	}
	return ""
}

func (m *GameSvrState) GetVGameIP() string {
	if m != nil {
		return m.VGameIP
	}
	return ""
}

func (m *GameSvrState) GetIZoneAreaID() uint32 {
	if m != nil {
		return m.IZoneAreaID
	}
	return 0
}

type OwnGoodsItem struct {
	Id    uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	State uint32 `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *OwnGoodsItem) Reset()                    { *m = OwnGoodsItem{} }
func (m *OwnGoodsItem) String() string            { return proto.CompactTextString(m) }
func (*OwnGoodsItem) ProtoMessage()               {}
func (*OwnGoodsItem) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{25} }

func (m *OwnGoodsItem) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *OwnGoodsItem) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

type OwnGoodsInfo struct {
	List []*OwnGoodsItem `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *OwnGoodsInfo) Reset()                    { *m = OwnGoodsInfo{} }
func (m *OwnGoodsInfo) String() string            { return proto.CompactTextString(m) }
func (*OwnGoodsInfo) ProtoMessage()               {}
func (*OwnGoodsInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{26} }

func (m *OwnGoodsInfo) GetList() []*OwnGoodsItem {
	if m != nil {
		return m.List
	}
	return nil
}

type RectInfo struct {
	Xmin float64 `protobuf:"fixed64,1,opt,name=xmin,proto3" json:"xmin,omitempty"`
	Xmax float64 `protobuf:"fixed64,2,opt,name=xmax,proto3" json:"xmax,omitempty"`
	Ymin float64 `protobuf:"fixed64,3,opt,name=ymin,proto3" json:"ymin,omitempty"`
	Ymax float64 `protobuf:"fixed64,4,opt,name=ymax,proto3" json:"ymax,omitempty"`
}

func (m *RectInfo) Reset()                    { *m = RectInfo{} }
func (m *RectInfo) String() string            { return proto.CompactTextString(m) }
func (*RectInfo) ProtoMessage()               {}
func (*RectInfo) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{27} }

func (m *RectInfo) GetXmin() float64 {
	if m != nil {
		return m.Xmin
	}
	return 0
}

func (m *RectInfo) GetXmax() float64 {
	if m != nil {
		return m.Xmax
	}
	return 0
}

func (m *RectInfo) GetYmin() float64 {
	if m != nil {
		return m.Ymin
	}
	return 0
}

func (m *RectInfo) GetYmax() float64 {
	if m != nil {
		return m.Ymax
	}
	return 0
}

// CreateEntityReq 请求创建space消息
type CreateSpaceReq struct {
	CellappIndex uint32 `protobuf:"varint,1,opt,name=CellappIndex,proto3" json:"CellappIndex,omitempty"`
	SrvID        uint64 `protobuf:"varint,2,opt,name=SrvID,proto3" json:"SrvID,omitempty"`
}

func (m *CreateSpaceReq) Reset()                    { *m = CreateSpaceReq{} }
func (m *CreateSpaceReq) String() string            { return proto.CompactTextString(m) }
func (*CreateSpaceReq) ProtoMessage()               {}
func (*CreateSpaceReq) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{28} }

func (m *CreateSpaceReq) GetCellappIndex() uint32 {
	if m != nil {
		return m.CellappIndex
	}
	return 0
}

func (m *CreateSpaceReq) GetSrvID() uint64 {
	if m != nil {
		return m.SrvID
	}
	return 0
}

type CreateSpaceRet struct {
	SpaceID uint64    `protobuf:"varint,1,opt,name=SpaceID,proto3" json:"SpaceID,omitempty"`
	Srect   *RectInfo `protobuf:"bytes,2,opt,name=Srect" json:"Srect,omitempty"`
	CellID  uint64    `protobuf:"varint,3,opt,name=CellID,proto3" json:"CellID,omitempty"`
	Crect   *RectInfo `protobuf:"bytes,4,opt,name=Crect" json:"Crect,omitempty"`
	MapName string    `protobuf:"bytes,5,opt,name=MapName,proto3" json:"MapName,omitempty"`
}

func (m *CreateSpaceRet) Reset()                    { *m = CreateSpaceRet{} }
func (m *CreateSpaceRet) String() string            { return proto.CompactTextString(m) }
func (*CreateSpaceRet) ProtoMessage()               {}
func (*CreateSpaceRet) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{29} }

func (m *CreateSpaceRet) GetSpaceID() uint64 {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *CreateSpaceRet) GetSrect() *RectInfo {
	if m != nil {
		return m.Srect
	}
	return nil
}

func (m *CreateSpaceRet) GetCellID() uint64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

func (m *CreateSpaceRet) GetCrect() *RectInfo {
	if m != nil {
		return m.Crect
	}
	return nil
}

func (m *CreateSpaceRet) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

type ReportCellLoad struct {
	SrvID    uint64            `protobuf:"varint,1,opt,name=srvID,proto3" json:"srvID,omitempty"`
	SpaceID  uint64            `protobuf:"varint,2,opt,name=spaceID,proto3" json:"spaceID,omitempty"`
	Cellload map[uint64]uint32 `protobuf:"bytes,3,rep,name=cellload" json:"cellload,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	SrvLoad  uint32            `protobuf:"varint,4,opt,name=srvLoad,proto3" json:"srvLoad,omitempty"`
}

func (m *ReportCellLoad) Reset()                    { *m = ReportCellLoad{} }
func (m *ReportCellLoad) String() string            { return proto.CompactTextString(m) }
func (*ReportCellLoad) ProtoMessage()               {}
func (*ReportCellLoad) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{30} }

func (m *ReportCellLoad) GetSrvID() uint64 {
	if m != nil {
		return m.SrvID
	}
	return 0
}

func (m *ReportCellLoad) GetSpaceID() uint64 {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *ReportCellLoad) GetCellload() map[uint64]uint32 {
	if m != nil {
		return m.Cellload
	}
	return nil
}

func (m *ReportCellLoad) GetSrvLoad() uint32 {
	if m != nil {
		return m.SrvLoad
	}
	return 0
}

// lobby-->CellMgr
type CellInfoReq struct {
	EntityID uint64   `protobuf:"varint,1,opt,name=entityID,proto3" json:"entityID,omitempty"`
	MapName  string   `protobuf:"bytes,2,opt,name=mapName,proto3" json:"mapName,omitempty"`
	Pos      *Vector3 `protobuf:"bytes,3,opt,name=pos" json:"pos,omitempty"`
	SrvID    uint64   `protobuf:"varint,4,opt,name=SrvID,proto3" json:"SrvID,omitempty"`
}

func (m *CellInfoReq) Reset()                    { *m = CellInfoReq{} }
func (m *CellInfoReq) String() string            { return proto.CompactTextString(m) }
func (*CellInfoReq) ProtoMessage()               {}
func (*CellInfoReq) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{31} }

func (m *CellInfoReq) GetEntityID() uint64 {
	if m != nil {
		return m.EntityID
	}
	return 0
}

func (m *CellInfoReq) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

func (m *CellInfoReq) GetPos() *Vector3 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *CellInfoReq) GetSrvID() uint64 {
	if m != nil {
		return m.SrvID
	}
	return 0
}

// CellMgr-->lobby
type CellInfoRet struct {
	EntityID  uint64   `protobuf:"varint,1,opt,name=entityID,proto3" json:"entityID,omitempty"`
	SpaceID   uint64   `protobuf:"varint,2,opt,name=spaceID,proto3" json:"spaceID,omitempty"`
	CellID    uint64   `protobuf:"varint,3,opt,name=cellID,proto3" json:"cellID,omitempty"`
	CellSrvID uint64   `protobuf:"varint,4,opt,name=cellSrvID,proto3" json:"cellSrvID,omitempty"`
	Pos       *Vector3 `protobuf:"bytes,5,opt,name=pos" json:"pos,omitempty"`
}

func (m *CellInfoRet) Reset()                    { *m = CellInfoRet{} }
func (m *CellInfoRet) String() string            { return proto.CompactTextString(m) }
func (*CellInfoRet) ProtoMessage()               {}
func (*CellInfoRet) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{32} }

func (m *CellInfoRet) GetEntityID() uint64 {
	if m != nil {
		return m.EntityID
	}
	return 0
}

func (m *CellInfoRet) GetSpaceID() uint64 {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *CellInfoRet) GetCellID() uint64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

func (m *CellInfoRet) GetCellSrvID() uint64 {
	if m != nil {
		return m.CellSrvID
	}
	return 0
}

func (m *CellInfoRet) GetPos() *Vector3 {
	if m != nil {
		return m.Pos
	}
	return nil
}

// CellMgr-->cell主动通知cell边界的变化
type CellBorderChangeNotify struct {
	SpaceID  uint64    `protobuf:"varint,1,opt,name=spaceID,proto3" json:"spaceID,omitempty"`
	CellID   uint64    `protobuf:"varint,2,opt,name=cellID,proto3" json:"cellID,omitempty"`
	Rectinfo *RectInfo `protobuf:"bytes,3,opt,name=rectinfo" json:"rectinfo,omitempty"`
}

func (m *CellBorderChangeNotify) Reset()                    { *m = CellBorderChangeNotify{} }
func (m *CellBorderChangeNotify) String() string            { return proto.CompactTextString(m) }
func (*CellBorderChangeNotify) ProtoMessage()               {}
func (*CellBorderChangeNotify) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{33} }

func (m *CellBorderChangeNotify) GetSpaceID() uint64 {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *CellBorderChangeNotify) GetCellID() uint64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

func (m *CellBorderChangeNotify) GetRectinfo() *RectInfo {
	if m != nil {
		return m.Rectinfo
	}
	return nil
}

// 广播给所有cellapp,新增、删除或修改cellinfo
// 目前是通过cellmgr进行广播，没有通过redis拿到所有server，再去广播
type CellInfoNotify struct {
	Operate  uint32    `protobuf:"varint,1,opt,name=operate,proto3" json:"operate,omitempty"`
	SpaceID  uint64    `protobuf:"varint,2,opt,name=spaceID,proto3" json:"spaceID,omitempty"`
	CellID   uint64    `protobuf:"varint,3,opt,name=cellID,proto3" json:"cellID,omitempty"`
	RectInfo *RectInfo `protobuf:"bytes,4,opt,name=rectInfo" json:"rectInfo,omitempty"`
	SrvID    uint64    `protobuf:"varint,5,opt,name=srvID,proto3" json:"srvID,omitempty"`
}

func (m *CellInfoNotify) Reset()                    { *m = CellInfoNotify{} }
func (m *CellInfoNotify) String() string            { return proto.CompactTextString(m) }
func (*CellInfoNotify) ProtoMessage()               {}
func (*CellInfoNotify) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{34} }

func (m *CellInfoNotify) GetOperate() uint32 {
	if m != nil {
		return m.Operate
	}
	return 0
}

func (m *CellInfoNotify) GetSpaceID() uint64 {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *CellInfoNotify) GetCellID() uint64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

func (m *CellInfoNotify) GetRectInfo() *RectInfo {
	if m != nil {
		return m.RectInfo
	}
	return nil
}

func (m *CellInfoNotify) GetSrvID() uint64 {
	if m != nil {
		return m.SrvID
	}
	return 0
}

// 通知cellapp创建新的cell
type CreateCellNotify struct {
	SpaceID uint64    `protobuf:"varint,1,opt,name=SpaceID,proto3" json:"SpaceID,omitempty"`
	Srect   *RectInfo `protobuf:"bytes,2,opt,name=Srect" json:"Srect,omitempty"`
	CellID  uint64    `protobuf:"varint,3,opt,name=CellID,proto3" json:"CellID,omitempty"`
	Crect   *RectInfo `protobuf:"bytes,4,opt,name=Crect" json:"Crect,omitempty"`
	MapName string    `protobuf:"bytes,5,opt,name=MapName,proto3" json:"MapName,omitempty"`
}

func (m *CreateCellNotify) Reset()                    { *m = CreateCellNotify{} }
func (m *CreateCellNotify) String() string            { return proto.CompactTextString(m) }
func (*CreateCellNotify) ProtoMessage()               {}
func (*CreateCellNotify) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{35} }

func (m *CreateCellNotify) GetSpaceID() uint64 {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *CreateCellNotify) GetSrect() *RectInfo {
	if m != nil {
		return m.Srect
	}
	return nil
}

func (m *CreateCellNotify) GetCellID() uint64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

func (m *CreateCellNotify) GetCrect() *RectInfo {
	if m != nil {
		return m.Crect
	}
	return nil
}

func (m *CreateCellNotify) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

// 通知cellapp删除cell
type DeleteCellNotify struct {
	SpaceID uint64 `protobuf:"varint,1,opt,name=SpaceID,proto3" json:"SpaceID,omitempty"`
	CellID  uint64 `protobuf:"varint,3,opt,name=CellID,proto3" json:"CellID,omitempty"`
}

func (m *DeleteCellNotify) Reset()                    { *m = DeleteCellNotify{} }
func (m *DeleteCellNotify) String() string            { return proto.CompactTextString(m) }
func (*DeleteCellNotify) ProtoMessage()               {}
func (*DeleteCellNotify) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{36} }

func (m *DeleteCellNotify) GetSpaceID() uint64 {
	if m != nil {
		return m.SpaceID
	}
	return 0
}

func (m *DeleteCellNotify) GetCellID() uint64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

type SkillEffect struct {
	Recoverhp     uint32   `protobuf:"varint,1,opt,name=recoverhp,proto3" json:"recoverhp,omitempty"`
	Damage        uint32   `protobuf:"varint,2,opt,name=damage,proto3" json:"damage,omitempty"`
	ReduceDefence uint32   `protobuf:"varint,3,opt,name=reduceDefence,proto3" json:"reduceDefence,omitempty"`
	AddDefence    uint32   `protobuf:"varint,4,opt,name=addDefence,proto3" json:"addDefence,omitempty"`
	State         uint32   `protobuf:"varint,5,opt,name=state,proto3" json:"state,omitempty"`
	Bufflist      []uint32 `protobuf:"varint,6,rep,packed,name=bufflist" json:"bufflist,omitempty"`
}

func (m *SkillEffect) Reset()                    { *m = SkillEffect{} }
func (m *SkillEffect) String() string            { return proto.CompactTextString(m) }
func (*SkillEffect) ProtoMessage()               {}
func (*SkillEffect) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{37} }

func (m *SkillEffect) GetRecoverhp() uint32 {
	if m != nil {
		return m.Recoverhp
	}
	return 0
}

func (m *SkillEffect) GetDamage() uint32 {
	if m != nil {
		return m.Damage
	}
	return 0
}

func (m *SkillEffect) GetReduceDefence() uint32 {
	if m != nil {
		return m.ReduceDefence
	}
	return 0
}

func (m *SkillEffect) GetAddDefence() uint32 {
	if m != nil {
		return m.AddDefence
	}
	return 0
}

func (m *SkillEffect) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *SkillEffect) GetBufflist() []uint32 {
	if m != nil {
		return m.Bufflist
	}
	return nil
}

type AttackReq struct {
	SkillID  uint32  `protobuf:"varint,1,opt,name=skillID,proto3" json:"skillID,omitempty"`
	TargetID uint64  `protobuf:"varint,2,opt,name=targetID,proto3" json:"targetID,omitempty"`
	X        float32 `protobuf:"fixed32,3,opt,name=x,proto3" json:"x,omitempty"`
	Z        float32 `protobuf:"fixed32,4,opt,name=z,proto3" json:"z,omitempty"`
}

func (m *AttackReq) Reset()                    { *m = AttackReq{} }
func (m *AttackReq) String() string            { return proto.CompactTextString(m) }
func (*AttackReq) ProtoMessage()               {}
func (*AttackReq) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{38} }

func (m *AttackReq) GetSkillID() uint32 {
	if m != nil {
		return m.SkillID
	}
	return 0
}

func (m *AttackReq) GetTargetID() uint64 {
	if m != nil {
		return m.TargetID
	}
	return 0
}

func (m *AttackReq) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *AttackReq) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

// C->S
type MoveReq struct {
	Pos       *Vector3 `protobuf:"bytes,1,opt,name=pos" json:"pos,omitempty"`
	Rota      *Vector3 `protobuf:"bytes,2,opt,name=rota" json:"rota,omitempty"`
	Stoped    bool     `protobuf:"varint,3,opt,name=stoped,proto3" json:"stoped,omitempty"`
	Timestamp uint64   `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *MoveReq) Reset()                    { *m = MoveReq{} }
func (m *MoveReq) String() string            { return proto.CompactTextString(m) }
func (*MoveReq) ProtoMessage()               {}
func (*MoveReq) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{39} }

func (m *MoveReq) GetPos() *Vector3 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *MoveReq) GetRota() *Vector3 {
	if m != nil {
		return m.Rota
	}
	return nil
}

func (m *MoveReq) GetStoped() bool {
	if m != nil {
		return m.Stoped
	}
	return false
}

func (m *MoveReq) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// S->C
type MoveUpdate struct {
	EntityID  uint64   `protobuf:"varint,1,opt,name=entityID,proto3" json:"entityID,omitempty"`
	Pos       *Vector3 `protobuf:"bytes,2,opt,name=pos" json:"pos,omitempty"`
	Rota      *Vector3 `protobuf:"bytes,3,opt,name=rota" json:"rota,omitempty"`
	Stoped    bool     `protobuf:"varint,4,opt,name=stoped,proto3" json:"stoped,omitempty"`
	Timestamp uint64   `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *MoveUpdate) Reset()                    { *m = MoveUpdate{} }
func (m *MoveUpdate) String() string            { return proto.CompactTextString(m) }
func (*MoveUpdate) ProtoMessage()               {}
func (*MoveUpdate) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{40} }

func (m *MoveUpdate) GetEntityID() uint64 {
	if m != nil {
		return m.EntityID
	}
	return 0
}

func (m *MoveUpdate) GetPos() *Vector3 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *MoveUpdate) GetRota() *Vector3 {
	if m != nil {
		return m.Rota
	}
	return nil
}

func (m *MoveUpdate) GetStoped() bool {
	if m != nil {
		return m.Stoped
	}
	return false
}

func (m *MoveUpdate) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type DetectCell struct {
}

func (m *DetectCell) Reset()                    { *m = DetectCell{} }
func (m *DetectCell) String() string            { return proto.CompactTextString(m) }
func (*DetectCell) ProtoMessage()               {}
func (*DetectCell) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{41} }

// S->C 进入cell成功
type EnterCellOk struct {
	MapID   uint32   `protobuf:"varint,1,opt,name=mapID,proto3" json:"mapID,omitempty"`
	MapName string   `protobuf:"bytes,2,opt,name=mapName,proto3" json:"mapName,omitempty"`
	Pos     *Vector3 `protobuf:"bytes,3,opt,name=pos" json:"pos,omitempty"`
	Rota    *Vector3 `protobuf:"bytes,4,opt,name=rota" json:"rota,omitempty"`
	CellID  uint64   `protobuf:"varint,5,opt,name=cellID,proto3" json:"cellID,omitempty"`
}

func (m *EnterCellOk) Reset()                    { *m = EnterCellOk{} }
func (m *EnterCellOk) String() string            { return proto.CompactTextString(m) }
func (*EnterCellOk) ProtoMessage()               {}
func (*EnterCellOk) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{42} }

func (m *EnterCellOk) GetMapID() uint32 {
	if m != nil {
		return m.MapID
	}
	return 0
}

func (m *EnterCellOk) GetMapName() string {
	if m != nil {
		return m.MapName
	}
	return ""
}

func (m *EnterCellOk) GetPos() *Vector3 {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *EnterCellOk) GetRota() *Vector3 {
	if m != nil {
		return m.Rota
	}
	return nil
}

func (m *EnterCellOk) GetCellID() uint64 {
	if m != nil {
		return m.CellID
	}
	return 0
}

type EffectNotify struct {
	EntityID    uint64     `protobuf:"varint,1,opt,name=entityID,proto3" json:"entityID,omitempty"`
	EffectType  EffectType `protobuf:"varint,2,opt,name=effectType,proto3,enum=protoMsg.EffectType" json:"effectType,omitempty"`
	EffectParam int64      `protobuf:"varint,3,opt,name=effectParam,proto3" json:"effectParam,omitempty"`
}

func (m *EffectNotify) Reset()                    { *m = EffectNotify{} }
func (m *EffectNotify) String() string            { return proto.CompactTextString(m) }
func (*EffectNotify) ProtoMessage()               {}
func (*EffectNotify) Descriptor() ([]byte, []int) { return fileDescriptorGame, []int{43} }

func (m *EffectNotify) GetEntityID() uint64 {
	if m != nil {
		return m.EntityID
	}
	return 0
}

func (m *EffectNotify) GetEffectType() EffectType {
	if m != nil {
		return m.EffectType
	}
	return EffectType_Damage
}

func (m *EffectNotify) GetEffectParam() int64 {
	if m != nil {
		return m.EffectParam
	}
	return 0
}

func init() {
	proto.RegisterType((*UserMainDataNotify)(nil), "protoMsg.UserMainDataNotify")
	proto.RegisterType((*Vector3)(nil), "protoMsg.Vector3")
	proto.RegisterType((*PlayerRegister)(nil), "protoMsg.PlayerRegister")
	proto.RegisterType((*PlayerLogin)(nil), "protoMsg.PlayerLogin")
	proto.RegisterType((*PlayerLogout)(nil), "protoMsg.PlayerLogout")
	proto.RegisterType((*MailObject)(nil), "protoMsg.MailObject")
	proto.RegisterType((*MailInfo)(nil), "protoMsg.MailInfo")
	proto.RegisterType((*ReqGetMailList)(nil), "protoMsg.ReqGetMailList")
	proto.RegisterType((*RetMailList)(nil), "protoMsg.RetMailList")
	proto.RegisterType((*ReqMailInfo)(nil), "protoMsg.ReqMailInfo")
	proto.RegisterType((*RetMailInfo)(nil), "protoMsg.RetMailInfo")
	proto.RegisterType((*DelMail)(nil), "protoMsg.DelMail")
	proto.RegisterType((*GetMailObj)(nil), "protoMsg.GetMailObj")
	proto.RegisterType((*AnnuonceInfo)(nil), "protoMsg.AnnuonceInfo")
	proto.RegisterType((*InitAnnuonceInfoRet)(nil), "protoMsg.InitAnnuonceInfoRet")
	proto.RegisterType((*FriendInfo)(nil), "protoMsg.FriendInfo")
	proto.RegisterType((*PlatFriendStateReq)(nil), "protoMsg.PlatFriendStateReq")
	proto.RegisterType((*PlatFriendState)(nil), "protoMsg.PlatFriendState")
	proto.RegisterType((*PlatFriendStateRet)(nil), "protoMsg.PlatFriendStateRet")
	proto.RegisterType((*FriendRankInfo)(nil), "protoMsg.FriendRankInfo")
	proto.RegisterType((*SyncFriendList)(nil), "protoMsg.SyncFriendList")
	proto.RegisterType((*FriendApplyInfo)(nil), "protoMsg.FriendApplyInfo")
	proto.RegisterType((*SyncFriendApplyList)(nil), "protoMsg.SyncFriendApplyList")
	proto.RegisterType((*DoSendItemReq)(nil), "protoMsg.DoSendItemReq")
	proto.RegisterType((*GameSvrState)(nil), "protoMsg.GameSvrState")
	proto.RegisterType((*OwnGoodsItem)(nil), "protoMsg.OwnGoodsItem")
	proto.RegisterType((*OwnGoodsInfo)(nil), "protoMsg.OwnGoodsInfo")
	proto.RegisterType((*RectInfo)(nil), "protoMsg.RectInfo")
	proto.RegisterType((*CreateSpaceReq)(nil), "protoMsg.CreateSpaceReq")
	proto.RegisterType((*CreateSpaceRet)(nil), "protoMsg.CreateSpaceRet")
	proto.RegisterType((*ReportCellLoad)(nil), "protoMsg.ReportCellLoad")
	proto.RegisterType((*CellInfoReq)(nil), "protoMsg.CellInfoReq")
	proto.RegisterType((*CellInfoRet)(nil), "protoMsg.CellInfoRet")
	proto.RegisterType((*CellBorderChangeNotify)(nil), "protoMsg.CellBorderChangeNotify")
	proto.RegisterType((*CellInfoNotify)(nil), "protoMsg.CellInfoNotify")
	proto.RegisterType((*CreateCellNotify)(nil), "protoMsg.CreateCellNotify")
	proto.RegisterType((*DeleteCellNotify)(nil), "protoMsg.DeleteCellNotify")
	proto.RegisterType((*SkillEffect)(nil), "protoMsg.SkillEffect")
	proto.RegisterType((*AttackReq)(nil), "protoMsg.AttackReq")
	proto.RegisterType((*MoveReq)(nil), "protoMsg.MoveReq")
	proto.RegisterType((*MoveUpdate)(nil), "protoMsg.MoveUpdate")
	proto.RegisterType((*DetectCell)(nil), "protoMsg.DetectCell")
	proto.RegisterType((*EnterCellOk)(nil), "protoMsg.EnterCellOk")
	proto.RegisterType((*EffectNotify)(nil), "protoMsg.EffectNotify")
	proto.RegisterEnum("protoMsg.EffectType", EffectType_name, EffectType_value)
}
func (m *UserMainDataNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserMainDataNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	if len(m.Name_) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name_)))
		i += copy(dAtA[i:], m.Name_)
	}
	if m.Coins != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Coins))
	}
	if m.Diams != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Diams))
	}
	return i, nil
}

func (m *Vector3) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector3) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Game(dAtA, i, uint32(math.Float32bits(float32(m.X))))
	}
	if m.Y != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Game(dAtA, i, uint32(math.Float32bits(float32(m.Y))))
	}
	if m.Z != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Game(dAtA, i, uint32(math.Float32bits(float32(m.Z))))
	}
	return i, nil
}

func (m *PlayerRegister) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerRegister) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameSvrID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.GameSvrID)))
		i += copy(dAtA[i:], m.GameSvrID)
	}
	if len(m.DtEventTime) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.DtEventTime)))
		i += copy(dAtA[i:], m.DtEventTime)
	}
	if len(m.VGameAppID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VGameAppID)))
		i += copy(dAtA[i:], m.VGameAppID)
	}
	if m.PlatID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlatID))
	}
	if m.IZoneAreaID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.IZoneAreaID))
	}
	if len(m.VOpenID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VOpenID)))
		i += copy(dAtA[i:], m.VOpenID)
	}
	if len(m.TelecomOper) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.TelecomOper)))
		i += copy(dAtA[i:], m.TelecomOper)
	}
	if len(m.RegChannel) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.RegChannel)))
		i += copy(dAtA[i:], m.RegChannel)
	}
	if m.LoginChannel != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.LoginChannel))
	}
	return i, nil
}

func (m *PlayerLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerLogin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameSvrID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.GameSvrID)))
		i += copy(dAtA[i:], m.GameSvrID)
	}
	if len(m.DtEventTime) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.DtEventTime)))
		i += copy(dAtA[i:], m.DtEventTime)
	}
	if len(m.VGameAppID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VGameAppID)))
		i += copy(dAtA[i:], m.VGameAppID)
	}
	if m.PlatID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlatID))
	}
	if m.IZoneAreaID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.IZoneAreaID))
	}
	if len(m.VOpenID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VOpenID)))
		i += copy(dAtA[i:], m.VOpenID)
	}
	if m.Level != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Level))
	}
	if m.PlayerFriendsNum != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerFriendsNum))
	}
	if len(m.ClientVersion) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.ClientVersion)))
		i += copy(dAtA[i:], m.ClientVersion)
	}
	if len(m.SystemHardware) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.SystemHardware)))
		i += copy(dAtA[i:], m.SystemHardware)
	}
	if len(m.TelecomOper) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.TelecomOper)))
		i += copy(dAtA[i:], m.TelecomOper)
	}
	if len(m.Network) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	if m.LoginChannel != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.LoginChannel))
	}
	if len(m.VRoleID) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VRoleID)))
		i += copy(dAtA[i:], m.VRoleID)
	}
	if len(m.VRoleName) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VRoleName)))
		i += copy(dAtA[i:], m.VRoleName)
	}
	if len(m.RegChannel) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.RegChannel)))
		i += copy(dAtA[i:], m.RegChannel)
	}
	return i, nil
}

func (m *PlayerLogout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerLogout) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameSvrID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.GameSvrID)))
		i += copy(dAtA[i:], m.GameSvrID)
	}
	if len(m.DtEventTime) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.DtEventTime)))
		i += copy(dAtA[i:], m.DtEventTime)
	}
	if len(m.VGameAppID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VGameAppID)))
		i += copy(dAtA[i:], m.VGameAppID)
	}
	if m.PlatID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlatID))
	}
	if m.IZoneAreaID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.IZoneAreaID))
	}
	if len(m.VOpenID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VOpenID)))
		i += copy(dAtA[i:], m.VOpenID)
	}
	if m.OnlineTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.OnlineTime))
	}
	if m.Level != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Level))
	}
	if m.PlayerFriendsNum != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.PlayerFriendsNum))
	}
	if len(m.ClientVersion) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.ClientVersion)))
		i += copy(dAtA[i:], m.ClientVersion)
	}
	if len(m.SystemHardware) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.SystemHardware)))
		i += copy(dAtA[i:], m.SystemHardware)
	}
	if len(m.TelecomOper) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.TelecomOper)))
		i += copy(dAtA[i:], m.TelecomOper)
	}
	if len(m.Network) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Network)))
		i += copy(dAtA[i:], m.Network)
	}
	return i, nil
}

func (m *MailObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailObject) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
	}
	if m.Num != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Num))
	}
	return i, nil
}

func (m *MailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mailid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Mailid))
	}
	if m.Mailtype != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Mailtype))
	}
	if m.Gettime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Gettime))
	}
	if m.Haveread {
		dAtA[i] = 0x20
		i++
		if m.Haveread {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Text) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Text)))
		i += copy(dAtA[i:], m.Text)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Objs) > 0 {
		for _, msg := range m.Objs {
			dAtA[i] = 0x42
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Haveget {
		dAtA[i] = 0x48
		i++
		if m.Haveget {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Button) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Button)))
		i += copy(dAtA[i:], m.Button)
	}
	return i, nil
}

func (m *ReqGetMailList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqGetMailList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RetMailList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetMailList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mails) > 0 {
		for _, msg := range m.Mails {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReqMailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReqMailInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mailid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Mailid))
	}
	return i, nil
}

func (m *RetMailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RetMailInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mail != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Mail.Size()))
		n1, err := m.Mail.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *DelMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelMail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mailid) > 0 {
		dAtA3 := make([]byte, len(m.Mailid)*10)
		var j2 int
		for _, num := range m.Mailid {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	return i, nil
}

func (m *GetMailObj) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMailObj) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Mailid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Mailid))
	}
	return i, nil
}

func (m *AnnuonceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnnuonceInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.EndTime))
	}
	if m.InternalTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.InternalTime))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *InitAnnuonceInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitAnnuonceInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, msg := range m.Item {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FriendInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
	}
	if len(m.Name_) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name_)))
		i += copy(dAtA[i:], m.Name_)
	}
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.State))
	}
	if m.Time != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Time))
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if len(m.Enterplat) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Enterplat)))
		i += copy(dAtA[i:], m.Enterplat)
	}
	if m.Qqvip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Qqvip))
	}
	if len(m.Nickname) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Nickname)))
		i += copy(dAtA[i:], m.Nickname)
	}
	return i, nil
}

func (m *PlatFriendStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatFriendStateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Openid) > 0 {
		for _, s := range m.Openid {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PlatFriendState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatFriendState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Openid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Openid)))
		i += copy(dAtA[i:], m.Openid)
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.State))
	}
	if m.Time != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Time))
	}
	if len(m.Name_) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name_)))
		i += copy(dAtA[i:], m.Name_)
	}
	return i, nil
}

func (m *PlatFriendStateRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlatFriendStateRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, msg := range m.Data {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FriendRankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendRankInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Uid))
	}
	if len(m.Name_) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name_)))
		i += copy(dAtA[i:], m.Name_)
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	if m.SoloRating != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Game(dAtA, i, uint32(math.Float32bits(float32(m.SoloRating))))
	}
	if m.DuoRating != 0 {
		dAtA[i] = 0x2d
		i++
		i = encodeFixed32Game(dAtA, i, uint32(math.Float32bits(float32(m.DuoRating))))
	}
	if m.SquadRating != 0 {
		dAtA[i] = 0x35
		i++
		i = encodeFixed32Game(dAtA, i, uint32(math.Float32bits(float32(m.SquadRating))))
	}
	if m.QqVip != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.QqVip))
	}
	if len(m.GameEenter) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.GameEenter)))
		i += copy(dAtA[i:], m.GameEenter)
	}
	return i, nil
}

func (m *SyncFriendList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncFriendList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, msg := range m.Item {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FriendApplyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendApplyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
	}
	if len(m.Name_) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Name_)))
		i += copy(dAtA[i:], m.Name_)
	}
	if m.ApplyTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ApplyTime))
	}
	return i, nil
}

func (m *SyncFriendApplyList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncFriendApplyList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, msg := range m.Item {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DoSendItemReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoSendItemReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if len(m.Objs) > 0 {
		for _, msg := range m.Objs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Url) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.Url)))
		i += copy(dAtA[i:], m.Url)
	}
	return i, nil
}

func (m *GameSvrState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GameSvrState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DtEventTime) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.DtEventTime)))
		i += copy(dAtA[i:], m.DtEventTime)
	}
	if len(m.VGameIP) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.VGameIP)))
		i += copy(dAtA[i:], m.VGameIP)
	}
	if m.IZoneAreaID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.IZoneAreaID))
	}
	return i, nil
}

func (m *OwnGoodsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnGoodsItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Id))
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *OwnGoodsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnGoodsInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, msg := range m.List {
			dAtA[i] = 0xa
			i++
			i = encodeVarintGame(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RectInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Xmin != 0 {
		dAtA[i] = 0x9
		i++
		i = encodeFixed64Game(dAtA, i, uint64(math.Float64bits(float64(m.Xmin))))
	}
	if m.Xmax != 0 {
		dAtA[i] = 0x11
		i++
		i = encodeFixed64Game(dAtA, i, uint64(math.Float64bits(float64(m.Xmax))))
	}
	if m.Ymin != 0 {
		dAtA[i] = 0x19
		i++
		i = encodeFixed64Game(dAtA, i, uint64(math.Float64bits(float64(m.Ymin))))
	}
	if m.Ymax != 0 {
		dAtA[i] = 0x21
		i++
		i = encodeFixed64Game(dAtA, i, uint64(math.Float64bits(float64(m.Ymax))))
	}
	return i, nil
}

func (m *CreateSpaceReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpaceReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CellappIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellappIndex))
	}
	if m.SrvID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SrvID))
	}
	return i, nil
}

func (m *CreateSpaceRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSpaceRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpaceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SpaceID))
	}
	if m.Srect != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Srect.Size()))
		n4, err := m.Srect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.CellID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellID))
	}
	if m.Crect != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Crect.Size()))
		n5, err := m.Crect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.MapName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.MapName)))
		i += copy(dAtA[i:], m.MapName)
	}
	return i, nil
}

func (m *ReportCellLoad) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportCellLoad) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SrvID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SrvID))
	}
	if m.SpaceID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SpaceID))
	}
	if len(m.Cellload) > 0 {
		for k, _ := range m.Cellload {
			dAtA[i] = 0x1a
			i++
			v := m.Cellload[k]
			mapSize := 1 + sovGame(uint64(k)) + 1 + sovGame(uint64(v))
			i = encodeVarintGame(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintGame(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintGame(dAtA, i, uint64(v))
		}
	}
	if m.SrvLoad != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SrvLoad))
	}
	return i, nil
}

func (m *CellInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellInfoReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntityID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.EntityID))
	}
	if len(m.MapName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.MapName)))
		i += copy(dAtA[i:], m.MapName)
	}
	if m.Pos != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Pos.Size()))
		n6, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.SrvID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SrvID))
	}
	return i, nil
}

func (m *CellInfoRet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellInfoRet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntityID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.EntityID))
	}
	if m.SpaceID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SpaceID))
	}
	if m.CellID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellID))
	}
	if m.CellSrvID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellSrvID))
	}
	if m.Pos != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Pos.Size()))
		n7, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *CellBorderChangeNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellBorderChangeNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpaceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SpaceID))
	}
	if m.CellID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellID))
	}
	if m.Rectinfo != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Rectinfo.Size()))
		n8, err := m.Rectinfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *CellInfoNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellInfoNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Operate != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Operate))
	}
	if m.SpaceID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SpaceID))
	}
	if m.CellID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellID))
	}
	if m.RectInfo != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.RectInfo.Size()))
		n9, err := m.RectInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.SrvID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SrvID))
	}
	return i, nil
}

func (m *CreateCellNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateCellNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpaceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SpaceID))
	}
	if m.Srect != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Srect.Size()))
		n10, err := m.Srect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.CellID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellID))
	}
	if m.Crect != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Crect.Size()))
		n11, err := m.Crect.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.MapName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.MapName)))
		i += copy(dAtA[i:], m.MapName)
	}
	return i, nil
}

func (m *DeleteCellNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteCellNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SpaceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SpaceID))
	}
	if m.CellID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellID))
	}
	return i, nil
}

func (m *SkillEffect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillEffect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Recoverhp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Recoverhp))
	}
	if m.Damage != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Damage))
	}
	if m.ReduceDefence != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.ReduceDefence))
	}
	if m.AddDefence != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.AddDefence))
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.State))
	}
	if len(m.Bufflist) > 0 {
		dAtA13 := make([]byte, len(m.Bufflist)*10)
		var j12 int
		for _, num := range m.Bufflist {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintGame(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	return i, nil
}

func (m *AttackReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.SkillID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.SkillID))
	}
	if m.TargetID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.TargetID))
	}
	if m.X != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Game(dAtA, i, uint32(math.Float32bits(float32(m.X))))
	}
	if m.Z != 0 {
		dAtA[i] = 0x25
		i++
		i = encodeFixed32Game(dAtA, i, uint32(math.Float32bits(float32(m.Z))))
	}
	return i, nil
}

func (m *MoveReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pos != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Pos.Size()))
		n14, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Rota != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Rota.Size()))
		n15, err := m.Rota.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.Stoped {
		dAtA[i] = 0x18
		i++
		if m.Stoped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *MoveUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveUpdate) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntityID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.EntityID))
	}
	if m.Pos != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Pos.Size()))
		n16, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Rota != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Rota.Size()))
		n17, err := m.Rota.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Stoped {
		dAtA[i] = 0x20
		i++
		if m.Stoped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Timestamp))
	}
	return i, nil
}

func (m *DetectCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DetectCell) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *EnterCellOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterCellOk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MapID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.MapID))
	}
	if len(m.MapName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintGame(dAtA, i, uint64(len(m.MapName)))
		i += copy(dAtA[i:], m.MapName)
	}
	if m.Pos != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Pos.Size()))
		n18, err := m.Pos.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Rota != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.Rota.Size()))
		n19, err := m.Rota.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.CellID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.CellID))
	}
	return i, nil
}

func (m *EffectNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EffectNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntityID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.EntityID))
	}
	if m.EffectType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.EffectType))
	}
	if m.EffectParam != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintGame(dAtA, i, uint64(m.EffectParam))
	}
	return i, nil
}

func encodeFixed64Game(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Game(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGame(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UserMainDataNotify) Name() string {
	return "UserMainDataNotify"
}

func (m *Vector3) Name() string {
	return "Vector3"
}

func (m *PlayerRegister) Name() string {
	return "PlayerRegister"
}

func (m *PlayerLogin) Name() string {
	return "PlayerLogin"
}

func (m *PlayerLogout) Name() string {
	return "PlayerLogout"
}

func (m *MailObject) Name() string {
	return "MailObject"
}

func (m *MailInfo) Name() string {
	return "MailInfo"
}

func (m *ReqGetMailList) Name() string {
	return "ReqGetMailList"
}

func (m *RetMailList) Name() string {
	return "RetMailList"
}

func (m *ReqMailInfo) Name() string {
	return "ReqMailInfo"
}

func (m *RetMailInfo) Name() string {
	return "RetMailInfo"
}

func (m *DelMail) Name() string {
	return "DelMail"
}

func (m *GetMailObj) Name() string {
	return "GetMailObj"
}

func (m *AnnuonceInfo) Name() string {
	return "AnnuonceInfo"
}

func (m *InitAnnuonceInfoRet) Name() string {
	return "InitAnnuonceInfoRet"
}

func (m *FriendInfo) Name() string {
	return "FriendInfo"
}

func (m *PlatFriendStateReq) Name() string {
	return "PlatFriendStateReq"
}

func (m *PlatFriendState) Name() string {
	return "PlatFriendState"
}

func (m *PlatFriendStateRet) Name() string {
	return "PlatFriendStateRet"
}

func (m *FriendRankInfo) Name() string {
	return "FriendRankInfo"
}

func (m *SyncFriendList) Name() string {
	return "SyncFriendList"
}

func (m *FriendApplyInfo) Name() string {
	return "FriendApplyInfo"
}

func (m *SyncFriendApplyList) Name() string {
	return "SyncFriendApplyList"
}

func (m *DoSendItemReq) Name() string {
	return "DoSendItemReq"
}

func (m *GameSvrState) Name() string {
	return "GameSvrState"
}

func (m *OwnGoodsItem) Name() string {
	return "OwnGoodsItem"
}

func (m *OwnGoodsInfo) Name() string {
	return "OwnGoodsInfo"
}

func (m *RectInfo) Name() string {
	return "RectInfo"
}

func (m *CreateSpaceReq) Name() string {
	return "CreateSpaceReq"
}

func (m *CreateSpaceRet) Name() string {
	return "CreateSpaceRet"
}

func (m *ReportCellLoad) Name() string {
	return "ReportCellLoad"
}

func (m *ReportCellLoad_CellloadEntry) Name() string {
	return "CellloadEntry"
}

func (m *CellInfoReq) Name() string {
	return "CellInfoReq"
}

func (m *CellInfoRet) Name() string {
	return "CellInfoRet"
}

func (m *CellBorderChangeNotify) Name() string {
	return "CellBorderChangeNotify"
}

func (m *CellInfoNotify) Name() string {
	return "CellInfoNotify"
}

func (m *CreateCellNotify) Name() string {
	return "CreateCellNotify"
}

func (m *DeleteCellNotify) Name() string {
	return "DeleteCellNotify"
}

func (m *SkillEffect) Name() string {
	return "SkillEffect"
}

func (m *AttackReq) Name() string {
	return "AttackReq"
}

func (m *MoveReq) Name() string {
	return "MoveReq"
}

func (m *MoveUpdate) Name() string {
	return "MoveUpdate"
}

func (m *DetectCell) Name() string {
	return "DetectCell"
}

func (m *EnterCellOk) Name() string {
	return "EnterCellOk"
}

func (m *EffectNotify) Name() string {
	return "EffectNotify"
}

func (m *UserMainDataNotify) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	l = len(m.Name_)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Coins != 0 {
		n += 1 + sovGame(uint64(m.Coins))
	}
	if m.Diams != 0 {
		n += 1 + sovGame(uint64(m.Diams))
	}
	return n
}

func (m *Vector3) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.Z != 0 {
		n += 5
	}
	return n
}

func (m *PlayerRegister) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameSvrID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.DtEventTime)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.VGameAppID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.PlatID != 0 {
		n += 1 + sovGame(uint64(m.PlatID))
	}
	if m.IZoneAreaID != 0 {
		n += 1 + sovGame(uint64(m.IZoneAreaID))
	}
	l = len(m.VOpenID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.TelecomOper)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.RegChannel)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.LoginChannel != 0 {
		n += 1 + sovGame(uint64(m.LoginChannel))
	}
	return n
}

func (m *PlayerLogin) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameSvrID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.DtEventTime)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.VGameAppID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.PlatID != 0 {
		n += 1 + sovGame(uint64(m.PlatID))
	}
	if m.IZoneAreaID != 0 {
		n += 1 + sovGame(uint64(m.IZoneAreaID))
	}
	l = len(m.VOpenID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovGame(uint64(m.Level))
	}
	if m.PlayerFriendsNum != 0 {
		n += 1 + sovGame(uint64(m.PlayerFriendsNum))
	}
	l = len(m.ClientVersion)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.SystemHardware)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.TelecomOper)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.LoginChannel != 0 {
		n += 1 + sovGame(uint64(m.LoginChannel))
	}
	l = len(m.VRoleID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.VRoleName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.RegChannel)
	if l > 0 {
		n += 2 + l + sovGame(uint64(l))
	}
	return n
}

func (m *PlayerLogout) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameSvrID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.DtEventTime)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.VGameAppID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.PlatID != 0 {
		n += 1 + sovGame(uint64(m.PlatID))
	}
	if m.IZoneAreaID != 0 {
		n += 1 + sovGame(uint64(m.IZoneAreaID))
	}
	l = len(m.VOpenID)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.OnlineTime != 0 {
		n += 1 + sovGame(uint64(m.OnlineTime))
	}
	if m.Level != 0 {
		n += 1 + sovGame(uint64(m.Level))
	}
	if m.PlayerFriendsNum != 0 {
		n += 1 + sovGame(uint64(m.PlayerFriendsNum))
	}
	l = len(m.ClientVersion)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.SystemHardware)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.TelecomOper)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Network)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *MailObject) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.Num != 0 {
		n += 1 + sovGame(uint64(m.Num))
	}
	return n
}

func (m *MailInfo) Size() (n int) {
	var l int
	_ = l
	if m.Mailid != 0 {
		n += 1 + sovGame(uint64(m.Mailid))
	}
	if m.Mailtype != 0 {
		n += 1 + sovGame(uint64(m.Mailtype))
	}
	if m.Gettime != 0 {
		n += 1 + sovGame(uint64(m.Gettime))
	}
	if m.Haveread {
		n += 2
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if len(m.Objs) > 0 {
		for _, e := range m.Objs {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	if m.Haveget {
		n += 2
	}
	l = len(m.Button)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *ReqGetMailList) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RetMailList) Size() (n int) {
	var l int
	_ = l
	if len(m.Mails) > 0 {
		for _, e := range m.Mails {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *ReqMailInfo) Size() (n int) {
	var l int
	_ = l
	if m.Mailid != 0 {
		n += 1 + sovGame(uint64(m.Mailid))
	}
	return n
}

func (m *RetMailInfo) Size() (n int) {
	var l int
	_ = l
	if m.Mail != nil {
		l = m.Mail.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *DelMail) Size() (n int) {
	var l int
	_ = l
	if len(m.Mailid) > 0 {
		l = 0
		for _, e := range m.Mailid {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	return n
}

func (m *GetMailObj) Size() (n int) {
	var l int
	_ = l
	if m.Mailid != 0 {
		n += 1 + sovGame(uint64(m.Mailid))
	}
	return n
}

func (m *AnnuonceInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.StartTime != 0 {
		n += 1 + sovGame(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovGame(uint64(m.EndTime))
	}
	if m.InternalTime != 0 {
		n += 1 + sovGame(uint64(m.InternalTime))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *InitAnnuonceInfoRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, e := range m.Item {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *FriendInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	l = len(m.Name_)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovGame(uint64(m.State))
	}
	if m.Time != 0 {
		n += 1 + sovGame(uint64(m.Time))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Enterplat)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Qqvip != 0 {
		n += 1 + sovGame(uint64(m.Qqvip))
	}
	l = len(m.Nickname)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *PlatFriendStateReq) Size() (n int) {
	var l int
	_ = l
	if len(m.Openid) > 0 {
		for _, s := range m.Openid {
			l = len(s)
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *PlatFriendState) Size() (n int) {
	var l int
	_ = l
	l = len(m.Openid)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	if m.State != 0 {
		n += 1 + sovGame(uint64(m.State))
	}
	if m.Time != 0 {
		n += 1 + sovGame(uint64(m.Time))
	}
	l = len(m.Name_)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *PlatFriendStateRet) Size() (n int) {
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *FriendRankInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGame(uint64(m.Uid))
	}
	l = len(m.Name_)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.SoloRating != 0 {
		n += 5
	}
	if m.DuoRating != 0 {
		n += 5
	}
	if m.SquadRating != 0 {
		n += 5
	}
	if m.QqVip != 0 {
		n += 1 + sovGame(uint64(m.QqVip))
	}
	l = len(m.GameEenter)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *SyncFriendList) Size() (n int) {
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, e := range m.Item {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *FriendApplyInfo) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	l = len(m.Name_)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.ApplyTime != 0 {
		n += 1 + sovGame(uint64(m.ApplyTime))
	}
	return n
}

func (m *SyncFriendApplyList) Size() (n int) {
	var l int
	_ = l
	if len(m.Item) > 0 {
		for _, e := range m.Item {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *DoSendItemReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if len(m.Objs) > 0 {
		for _, e := range m.Objs {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *GameSvrState) Size() (n int) {
	var l int
	_ = l
	l = len(m.DtEventTime)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.VGameIP)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.IZoneAreaID != 0 {
		n += 1 + sovGame(uint64(m.IZoneAreaID))
	}
	return n
}

func (m *OwnGoodsItem) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGame(uint64(m.Id))
	}
	if m.State != 0 {
		n += 1 + sovGame(uint64(m.State))
	}
	return n
}

func (m *OwnGoodsInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.List) > 0 {
		for _, e := range m.List {
			l = e.Size()
			n += 1 + l + sovGame(uint64(l))
		}
	}
	return n
}

func (m *RectInfo) Size() (n int) {
	var l int
	_ = l
	if m.Xmin != 0 {
		n += 9
	}
	if m.Xmax != 0 {
		n += 9
	}
	if m.Ymin != 0 {
		n += 9
	}
	if m.Ymax != 0 {
		n += 9
	}
	return n
}

func (m *CreateSpaceReq) Size() (n int) {
	var l int
	_ = l
	if m.CellappIndex != 0 {
		n += 1 + sovGame(uint64(m.CellappIndex))
	}
	if m.SrvID != 0 {
		n += 1 + sovGame(uint64(m.SrvID))
	}
	return n
}

func (m *CreateSpaceRet) Size() (n int) {
	var l int
	_ = l
	if m.SpaceID != 0 {
		n += 1 + sovGame(uint64(m.SpaceID))
	}
	if m.Srect != nil {
		l = m.Srect.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.CellID != 0 {
		n += 1 + sovGame(uint64(m.CellID))
	}
	if m.Crect != nil {
		l = m.Crect.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.MapName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *ReportCellLoad) Size() (n int) {
	var l int
	_ = l
	if m.SrvID != 0 {
		n += 1 + sovGame(uint64(m.SrvID))
	}
	if m.SpaceID != 0 {
		n += 1 + sovGame(uint64(m.SpaceID))
	}
	if len(m.Cellload) > 0 {
		for k, v := range m.Cellload {
			_ = k
			_ = v
			mapEntrySize := 1 + sovGame(uint64(k)) + 1 + sovGame(uint64(v))
			n += mapEntrySize + 1 + sovGame(uint64(mapEntrySize))
		}
	}
	if m.SrvLoad != 0 {
		n += 1 + sovGame(uint64(m.SrvLoad))
	}
	return n
}

func (m *CellInfoReq) Size() (n int) {
	var l int
	_ = l
	if m.EntityID != 0 {
		n += 1 + sovGame(uint64(m.EntityID))
	}
	l = len(m.MapName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.SrvID != 0 {
		n += 1 + sovGame(uint64(m.SrvID))
	}
	return n
}

func (m *CellInfoRet) Size() (n int) {
	var l int
	_ = l
	if m.EntityID != 0 {
		n += 1 + sovGame(uint64(m.EntityID))
	}
	if m.SpaceID != 0 {
		n += 1 + sovGame(uint64(m.SpaceID))
	}
	if m.CellID != 0 {
		n += 1 + sovGame(uint64(m.CellID))
	}
	if m.CellSrvID != 0 {
		n += 1 + sovGame(uint64(m.CellSrvID))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *CellBorderChangeNotify) Size() (n int) {
	var l int
	_ = l
	if m.SpaceID != 0 {
		n += 1 + sovGame(uint64(m.SpaceID))
	}
	if m.CellID != 0 {
		n += 1 + sovGame(uint64(m.CellID))
	}
	if m.Rectinfo != nil {
		l = m.Rectinfo.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *CellInfoNotify) Size() (n int) {
	var l int
	_ = l
	if m.Operate != 0 {
		n += 1 + sovGame(uint64(m.Operate))
	}
	if m.SpaceID != 0 {
		n += 1 + sovGame(uint64(m.SpaceID))
	}
	if m.CellID != 0 {
		n += 1 + sovGame(uint64(m.CellID))
	}
	if m.RectInfo != nil {
		l = m.RectInfo.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.SrvID != 0 {
		n += 1 + sovGame(uint64(m.SrvID))
	}
	return n
}

func (m *CreateCellNotify) Size() (n int) {
	var l int
	_ = l
	if m.SpaceID != 0 {
		n += 1 + sovGame(uint64(m.SpaceID))
	}
	if m.Srect != nil {
		l = m.Srect.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.CellID != 0 {
		n += 1 + sovGame(uint64(m.CellID))
	}
	if m.Crect != nil {
		l = m.Crect.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	l = len(m.MapName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	return n
}

func (m *DeleteCellNotify) Size() (n int) {
	var l int
	_ = l
	if m.SpaceID != 0 {
		n += 1 + sovGame(uint64(m.SpaceID))
	}
	if m.CellID != 0 {
		n += 1 + sovGame(uint64(m.CellID))
	}
	return n
}

func (m *SkillEffect) Size() (n int) {
	var l int
	_ = l
	if m.Recoverhp != 0 {
		n += 1 + sovGame(uint64(m.Recoverhp))
	}
	if m.Damage != 0 {
		n += 1 + sovGame(uint64(m.Damage))
	}
	if m.ReduceDefence != 0 {
		n += 1 + sovGame(uint64(m.ReduceDefence))
	}
	if m.AddDefence != 0 {
		n += 1 + sovGame(uint64(m.AddDefence))
	}
	if m.State != 0 {
		n += 1 + sovGame(uint64(m.State))
	}
	if len(m.Bufflist) > 0 {
		l = 0
		for _, e := range m.Bufflist {
			l += sovGame(uint64(e))
		}
		n += 1 + sovGame(uint64(l)) + l
	}
	return n
}

func (m *AttackReq) Size() (n int) {
	var l int
	_ = l
	if m.SkillID != 0 {
		n += 1 + sovGame(uint64(m.SkillID))
	}
	if m.TargetID != 0 {
		n += 1 + sovGame(uint64(m.TargetID))
	}
	if m.X != 0 {
		n += 5
	}
	if m.Z != 0 {
		n += 5
	}
	return n
}

func (m *MoveReq) Size() (n int) {
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Rota != nil {
		l = m.Rota.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Stoped {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovGame(uint64(m.Timestamp))
	}
	return n
}

func (m *MoveUpdate) Size() (n int) {
	var l int
	_ = l
	if m.EntityID != 0 {
		n += 1 + sovGame(uint64(m.EntityID))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Rota != nil {
		l = m.Rota.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Stoped {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovGame(uint64(m.Timestamp))
	}
	return n
}

func (m *DetectCell) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *EnterCellOk) Size() (n int) {
	var l int
	_ = l
	if m.MapID != 0 {
		n += 1 + sovGame(uint64(m.MapID))
	}
	l = len(m.MapName)
	if l > 0 {
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.Rota != nil {
		l = m.Rota.Size()
		n += 1 + l + sovGame(uint64(l))
	}
	if m.CellID != 0 {
		n += 1 + sovGame(uint64(m.CellID))
	}
	return n
}

func (m *EffectNotify) Size() (n int) {
	var l int
	_ = l
	if m.EntityID != 0 {
		n += 1 + sovGame(uint64(m.EntityID))
	}
	if m.EffectType != 0 {
		n += 1 + sovGame(uint64(m.EffectType))
	}
	if m.EffectParam != 0 {
		n += 1 + sovGame(uint64(m.EffectParam))
	}
	return n
}

func sovGame(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGame(x uint64) (n int) {
	return sovGame(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UserMainDataNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserMainDataNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserMainDataNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coins", wireType)
			}
			m.Coins = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Coins |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diams", wireType)
			}
			m.Diams = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diams |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector3) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector3: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector3: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.X = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Y = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerRegister) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerRegister: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerRegister: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameSvrID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameSvrID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEventTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtEventTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VGameAppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VGameAppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatID", wireType)
			}
			m.PlatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IZoneAreaID", wireType)
			}
			m.IZoneAreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IZoneAreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VOpenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VOpenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelecomOper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelecomOper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginChannel", wireType)
			}
			m.LoginChannel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginChannel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameSvrID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameSvrID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEventTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtEventTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VGameAppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VGameAppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatID", wireType)
			}
			m.PlatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IZoneAreaID", wireType)
			}
			m.IZoneAreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IZoneAreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VOpenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VOpenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerFriendsNum", wireType)
			}
			m.PlayerFriendsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerFriendsNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemHardware", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemHardware = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelecomOper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelecomOper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginChannel", wireType)
			}
			m.LoginChannel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LoginChannel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VRoleID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VRoleID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VRoleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VRoleName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerLogout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerLogout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerLogout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameSvrID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameSvrID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEventTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtEventTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VGameAppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VGameAppID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatID", wireType)
			}
			m.PlatID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlatID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IZoneAreaID", wireType)
			}
			m.IZoneAreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IZoneAreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VOpenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VOpenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlineTime", wireType)
			}
			m.OnlineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnlineTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerFriendsNum", wireType)
			}
			m.PlayerFriendsNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerFriendsNum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemHardware", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemHardware = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TelecomOper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TelecomOper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Network", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Network = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailid", wireType)
			}
			m.Mailid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mailid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailtype", wireType)
			}
			m.Mailtype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mailtype |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gettime", wireType)
			}
			m.Gettime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gettime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Haveread", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Haveread = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objs = append(m.Objs, &MailObject{})
			if err := m.Objs[len(m.Objs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Haveget", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Haveget = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Button", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Button = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqGetMailList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqGetMailList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqGetMailList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetMailList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetMailList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetMailList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mails = append(m.Mails, &MailInfo{})
			if err := m.Mails[len(m.Mails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReqMailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReqMailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReqMailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailid", wireType)
			}
			m.Mailid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mailid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RetMailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RetMailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RetMailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mail == nil {
				m.Mail = &MailInfo{}
			}
			if err := m.Mail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Mailid = append(m.Mailid, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Mailid = append(m.Mailid, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailid", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMailObj) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMailObj: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMailObj: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mailid", wireType)
			}
			m.Mailid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mailid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnnuonceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnnuonceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnnuonceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalTime", wireType)
			}
			m.InternalTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitAnnuonceInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitAnnuonceInfoRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitAnnuonceInfoRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, &AnnuonceInfo{})
			if err := m.Item[len(m.Item)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enterplat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Enterplat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qqvip", wireType)
			}
			m.Qqvip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qqvip |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nickname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nickname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatFriendStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatFriendStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatFriendStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Openid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Openid = append(m.Openid, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatFriendState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatFriendState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatFriendState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Openid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Openid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlatFriendStateRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlatFriendStateRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlatFriendStateRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &PlatFriendState{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendRankInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendRankInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendRankInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoloRating", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.SoloRating = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DuoRating", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.DuoRating = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SquadRating", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.SquadRating = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QqVip", wireType)
			}
			m.QqVip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QqVip |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameEenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameEenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncFriendList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncFriendList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncFriendList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, &FriendInfo{})
			if err := m.Item[len(m.Item)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendApplyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendApplyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendApplyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyTime", wireType)
			}
			m.ApplyTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncFriendApplyList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncFriendApplyList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncFriendApplyList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Item = append(m.Item, &FriendApplyInfo{})
			if err := m.Item[len(m.Item)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoSendItemReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoSendItemReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoSendItemReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Objs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Objs = append(m.Objs, &MailObject{})
			if err := m.Objs[len(m.Objs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameSvrState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameSvrState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameSvrState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DtEventTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DtEventTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VGameIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VGameIP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IZoneAreaID", wireType)
			}
			m.IZoneAreaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IZoneAreaID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnGoodsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnGoodsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnGoodsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnGoodsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnGoodsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnGoodsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.List = append(m.List, &OwnGoodsItem{})
			if err := m.List[len(m.List)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xmin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Xmin = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Xmax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Xmax = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ymin", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Ymin = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ymax", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(dAtA[iNdEx-8])
			v |= uint64(dAtA[iNdEx-7]) << 8
			v |= uint64(dAtA[iNdEx-6]) << 16
			v |= uint64(dAtA[iNdEx-5]) << 24
			v |= uint64(dAtA[iNdEx-4]) << 32
			v |= uint64(dAtA[iNdEx-3]) << 40
			v |= uint64(dAtA[iNdEx-2]) << 48
			v |= uint64(dAtA[iNdEx-1]) << 56
			m.Ymax = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpaceReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpaceReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpaceReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellappIndex", wireType)
			}
			m.CellappIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellappIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvID", wireType)
			}
			m.SrvID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrvID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSpaceRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSpaceRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSpaceRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Srect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Srect == nil {
				m.Srect = &RectInfo{}
			}
			if err := m.Srect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Crect == nil {
				m.Crect = &RectInfo{}
			}
			if err := m.Crect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportCellLoad) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportCellLoad: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportCellLoad: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvID", wireType)
			}
			m.SrvID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrvID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cellload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				mapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.Cellload == nil {
				m.Cellload = make(map[uint64]uint32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					mapvalue |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cellload[mapkey] = mapvalue
			} else {
				var mapvalue uint32
				m.Cellload[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvLoad", wireType)
			}
			m.SrvLoad = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrvLoad |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityID", wireType)
			}
			m.EntityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vector3{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvID", wireType)
			}
			m.SrvID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrvID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellInfoRet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellInfoRet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellInfoRet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityID", wireType)
			}
			m.EntityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellSrvID", wireType)
			}
			m.CellSrvID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellSrvID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vector3{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellBorderChangeNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellBorderChangeNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellBorderChangeNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rectinfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rectinfo == nil {
				m.Rectinfo = &RectInfo{}
			}
			if err := m.Rectinfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellInfoNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellInfoNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellInfoNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operate", wireType)
			}
			m.Operate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Operate |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RectInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RectInfo == nil {
				m.RectInfo = &RectInfo{}
			}
			if err := m.RectInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrvID", wireType)
			}
			m.SrvID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrvID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateCellNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateCellNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateCellNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Srect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Srect == nil {
				m.Srect = &RectInfo{}
			}
			if err := m.Srect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Crect == nil {
				m.Crect = &RectInfo{}
			}
			if err := m.Crect.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteCellNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteCellNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteCellNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceID", wireType)
			}
			m.SpaceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SpaceID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillEffect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillEffect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillEffect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recoverhp", wireType)
			}
			m.Recoverhp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Recoverhp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Damage", wireType)
			}
			m.Damage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Damage |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReduceDefence", wireType)
			}
			m.ReduceDefence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReduceDefence |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddDefence", wireType)
			}
			m.AddDefence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddDefence |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Bufflist = append(m.Bufflist, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGame
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGame
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGame
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Bufflist = append(m.Bufflist, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Bufflist", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			m.SkillID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetID", wireType)
			}
			m.TargetID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.X = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vector3{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rota", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rota == nil {
				m.Rota = &Vector3{}
			}
			if err := m.Rota.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stoped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stoped = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityID", wireType)
			}
			m.EntityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vector3{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rota", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rota == nil {
				m.Rota = &Vector3{}
			}
			if err := m.Rota.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stoped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stoped = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DetectCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DetectCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DetectCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnterCellOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterCellOk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterCellOk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapID", wireType)
			}
			m.MapID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MapID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MapName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Vector3{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rota", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGame
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rota == nil {
				m.Rota = &Vector3{}
			}
			if err := m.Rota.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellID", wireType)
			}
			m.CellID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CellID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EffectNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGame
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EffectNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EffectNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityID", wireType)
			}
			m.EntityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectType", wireType)
			}
			m.EffectType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectType |= (EffectType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EffectParam", wireType)
			}
			m.EffectParam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGame
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EffectParam |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGame(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGame
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGame(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGame
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGame
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGame
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGame
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGame(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGame = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGame   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("game.proto", fileDescriptorGame) }

var fileDescriptorGame = []byte{
	// 1698 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x4f, 0x8f, 0x1b, 0x49,
	0x15, 0xdf, 0xb6, 0xdb, 0xff, 0x9e, 0xdd, 0x1e, 0x4f, 0x27, 0x1b, 0x39, 0x08, 0x66, 0x87, 0x56,
	0x60, 0x87, 0x3d, 0x64, 0xd1, 0x66, 0x91, 0x56, 0x20, 0x56, 0x9a, 0x8c, 0x87, 0xc4, 0x28, 0x33,
	0x13, 0xec, 0x64, 0x24, 0xb8, 0x84, 0x9a, 0xee, 0x37, 0x4e, 0x67, 0xba, 0xab, 0x7a, 0xaa, 0xcb,
	0xce, 0x18, 0x21, 0x0e, 0x88, 0x03, 0xe2, 0x84, 0xb8, 0x70, 0xe6, 0xce, 0x67, 0x40, 0xe2, 0x86,
	0xc4, 0x85, 0x8f, 0x80, 0xc2, 0x97, 0xe0, 0x88, 0xea, 0x75, 0xf5, 0x1f, 0x7b, 0x3c, 0x13, 0x71,
	0xca, 0xc9, 0xae, 0xaa, 0x57, 0xef, 0xfd, 0xde, 0xaf, 0x7e, 0xef, 0x55, 0x35, 0xc0, 0x8c, 0xc5,
	0xf8, 0x30, 0x91, 0x42, 0x09, 0xb7, 0x4d, 0x3f, 0x47, 0xe9, 0xcc, 0x3b, 0x02, 0xf7, 0x65, 0x8a,
	0xf2, 0x88, 0x85, 0x7c, 0xc4, 0x14, 0x3b, 0x16, 0x2a, 0x3c, 0x5f, 0xba, 0x5d, 0xa8, 0xcf, 0xc3,
	0x60, 0x68, 0xed, 0x5a, 0x7b, 0xb6, 0xdb, 0x03, 0x9b, 0xb3, 0x18, 0x87, 0xb5, 0x5d, 0x6b, 0xaf,
	0xe3, 0x3a, 0xd0, 0xf0, 0x45, 0xc8, 0xd3, 0x61, 0x9d, 0x16, 0x1d, 0x68, 0x04, 0x21, 0x8b, 0xd3,
	0xa1, 0xad, 0x87, 0xde, 0x67, 0xd0, 0x3a, 0x45, 0x5f, 0x09, 0xf9, 0xc8, 0xed, 0x80, 0x75, 0x45,
	0x1e, 0x6a, 0xfa, 0xef, 0x92, 0xb6, 0xd3, 0xdf, 0x5f, 0xd1, 0xd6, 0x9a, 0xf7, 0x77, 0x0b, 0xfa,
	0xcf, 0x23, 0xb6, 0x44, 0x39, 0xc1, 0x59, 0x98, 0x2a, 0x94, 0xee, 0x36, 0x74, 0x9e, 0xb0, 0x18,
	0xa7, 0x0b, 0x39, 0x1e, 0xd1, 0xde, 0x8e, 0x7b, 0x07, 0xba, 0x23, 0x75, 0xb8, 0x40, 0xae, 0x5e,
	0x84, 0x05, 0x08, 0x17, 0xe0, 0x54, 0x1b, 0xee, 0x27, 0xc9, 0x78, 0x44, 0xee, 0x3a, 0x6e, 0x1f,
	0x9a, 0xcf, 0x23, 0xa6, 0xc6, 0x23, 0x82, 0xe2, 0xe8, 0x8d, 0xe3, 0x5f, 0x08, 0x8e, 0xfb, 0x12,
	0xd9, 0x78, 0x34, 0x6c, 0xd0, 0xe4, 0x16, 0xb4, 0x4e, 0x4f, 0x12, 0xe4, 0xe3, 0xd1, 0xb0, 0x99,
	0xbb, 0x7f, 0x81, 0x11, 0xfa, 0x22, 0x3e, 0x49, 0x50, 0x0e, 0x5b, 0xb9, 0xfb, 0x09, 0xce, 0x0e,
	0x5e, 0x33, 0xce, 0x31, 0x1a, 0xb6, 0x69, 0xee, 0x2e, 0xf4, 0x9e, 0x89, 0x59, 0xc8, 0xf3, 0xd9,
	0x8e, 0xf6, 0xe7, 0xfd, 0xb3, 0x06, 0xdd, 0x2c, 0x07, 0x5a, 0xfc, 0x00, 0x09, 0x38, 0xd0, 0x78,
	0x86, 0x0b, 0x8c, 0x08, 0xba, 0xe3, 0x0e, 0x61, 0x90, 0xe1, 0xf9, 0x89, 0x0c, 0x91, 0x07, 0xe9,
	0xf1, 0x3c, 0xa6, 0x04, 0x1c, 0xf7, 0x63, 0x70, 0x0e, 0xa2, 0x10, 0xb9, 0x3a, 0x45, 0x99, 0x86,
	0x82, 0x53, 0x06, 0x1d, 0xf7, 0x1e, 0xf4, 0xa7, 0xcb, 0x54, 0x61, 0xfc, 0x94, 0xc9, 0xe0, 0x2d,
	0x93, 0x38, 0x84, 0x4d, 0xc4, 0x74, 0x69, 0x72, 0x0b, 0x5a, 0xc7, 0xa8, 0xde, 0x0a, 0x79, 0x31,
	0xec, 0x6d, 0x64, 0xc5, 0x29, 0x40, 0x4e, 0x44, 0x84, 0xe3, 0xd1, 0xb0, 0x4f, 0x66, 0xdb, 0xd0,
	0xa1, 0x89, 0x63, 0xad, 0xa3, 0xad, 0x0d, 0x1c, 0x0f, 0xf4, 0x9c, 0xf7, 0xa7, 0x1a, 0xf4, 0x0a,
	0x36, 0xc5, 0x5c, 0x7d, 0x00, 0x3a, 0x5d, 0x80, 0x13, 0x1e, 0x85, 0x1c, 0xc9, 0x7b, 0xc6, 0x69,
	0x41, 0x71, 0xfb, 0x46, 0x8a, 0x3b, 0x9b, 0x29, 0x86, 0x1b, 0x28, 0xee, 0x6e, 0xa2, 0xb8, 0xb7,
	0x4e, 0xb1, 0x43, 0xa4, 0x7c, 0x07, 0xe0, 0x88, 0x85, 0xd1, 0xc9, 0xd9, 0x1b, 0xf4, 0x95, 0x0b,
	0x50, 0x33, 0x85, 0xe9, 0xe8, 0x2a, 0xe5, 0xf3, 0x98, 0x28, 0x70, 0xbc, 0xbf, 0x59, 0xd0, 0xd6,
	0x76, 0x63, 0x7e, 0x2e, 0x74, 0xee, 0x31, 0x0b, 0xa3, 0xa2, 0x84, 0x07, 0xd0, 0xd6, 0x63, 0xb5,
	0x4c, 0x32, 0xc6, 0x28, 0xf1, 0x19, 0x2a, 0xa5, 0x93, 0xac, 0xe7, 0x26, 0xaf, 0xd9, 0x02, 0x25,
	0xb2, 0x80, 0x08, 0x6b, 0xeb, 0xb4, 0x55, 0xa8, 0x22, 0x24, 0xaa, 0x3a, 0xba, 0x0d, 0x28, 0xbc,
	0x52, 0x86, 0x27, 0xdd, 0x21, 0x64, 0x64, 0xea, 0xc5, 0x03, 0x5b, 0x9c, 0xbd, 0x49, 0x87, 0xed,
	0xdd, 0xfa, 0x5e, 0xf7, 0x8b, 0xbb, 0x0f, 0xf3, 0xee, 0xf2, 0xb0, 0x02, 0x7c, 0x0b, 0x5a, 0xda,
	0xff, 0x0c, 0x15, 0x91, 0xd5, 0xd6, 0x18, 0xcf, 0xe6, 0x4a, 0xe5, 0x2c, 0x79, 0x03, 0xe8, 0x4f,
	0xf0, 0xf2, 0x09, 0x2a, 0xbd, 0xe9, 0x59, 0x98, 0x2a, 0xef, 0xfb, 0xd0, 0x9d, 0x94, 0x43, 0xf7,
	0xdb, 0xd0, 0xd0, 0x49, 0xa4, 0x43, 0x8b, 0xc2, 0xb8, 0xab, 0x61, 0x74, 0xde, 0xde, 0xb7, 0xf4,
	0x8e, 0xcb, 0x9b, 0x68, 0xf0, 0x3e, 0x2f, 0x1c, 0xd2, 0xf2, 0x2e, 0xd8, 0x7a, 0x99, 0x16, 0x37,
	0xfb, 0xbb, 0x0f, 0xad, 0x11, 0x46, 0x7a, 0xb8, 0xe2, 0xab, 0xbe, 0x67, 0x7b, 0xdf, 0x04, 0x30,
	0x58, 0x4f, 0xce, 0xde, 0x5c, 0x8b, 0x84, 0xd0, 0xdb, 0xe7, 0x7c, 0x2e, 0xb8, 0x8f, 0x14, 0xaa,
	0x3c, 0x36, 0x5b, 0x8b, 0x3a, 0x55, 0x4c, 0x96, 0xfa, 0xad, 0x6b, 0x72, 0x90, 0x07, 0x2f, 0xf2,
	0xd3, 0xa8, 0xeb, 0xba, 0x0a, 0xb9, 0x42, 0xc9, 0x59, 0x44, 0xb3, 0x76, 0x6e, 0xe6, 0x0b, 0xae,
	0x90, 0xab, 0xec, 0x4c, 0xbc, 0x1f, 0xc1, 0x9d, 0x31, 0x0f, 0x55, 0x35, 0xd4, 0x04, 0x95, 0xfb,
	0x00, 0xec, 0x50, 0x61, 0x6c, 0x88, 0xba, 0x57, 0x26, 0x56, 0x35, 0xf4, 0x7e, 0x67, 0x01, 0x64,
	0x12, 0xbe, 0x06, 0xf1, 0x5a, 0xcb, 0x4f, 0x15, 0x53, 0x19, 0x36, 0x87, 0x84, 0x90, 0x63, 0x72,
	0x72, 0x21, 0x34, 0xf2, 0x3a, 0x47, 0x0d, 0x3b, 0x89, 0x98, 0x2a, 0xfb, 0xd3, 0xe5, 0xe5, 0x22,
	0x4c, 0x4c, 0x2d, 0x0d, 0xa0, 0xcd, 0x43, 0xff, 0x82, 0xbc, 0x53, 0x63, 0xf5, 0x1e, 0x80, 0xab,
	0xeb, 0x34, 0x43, 0x32, 0xd5, 0x71, 0x26, 0x78, 0xa9, 0x09, 0x15, 0x09, 0x72, 0x43, 0x77, 0xc7,
	0xfb, 0x39, 0x6c, 0xad, 0x59, 0xad, 0x98, 0xe4, 0x92, 0x0c, 0x03, 0xc2, 0x6c, 0xdf, 0x8e, 0x39,
	0x4f, 0x2f, 0x23, 0xf1, 0xc7, 0x1b, 0x00, 0x28, 0xf7, 0x53, 0xb0, 0x03, 0xa6, 0x98, 0xe1, 0xf0,
	0x7e, 0xc9, 0xe1, 0x9a, 0xad, 0xf7, 0x67, 0x0b, 0xfa, 0xd9, 0x78, 0xc2, 0xf8, 0x05, 0x51, 0xd9,
	0x85, 0xfa, 0xcb, 0x2a, 0x97, 0xc7, 0x25, 0x97, 0x7a, 0x49, 0x46, 0xa6, 0x45, 0xb9, 0x00, 0x53,
	0x11, 0x89, 0x09, 0x53, 0x21, 0x9f, 0x11, 0xb6, 0x9a, 0xa6, 0x70, 0x34, 0xcf, 0xa7, 0x1a, 0x34,
	0x75, 0x07, 0xba, 0xd3, 0xcb, 0x39, 0x0b, 0xcc, 0x64, 0x93, 0x26, 0x1d, 0x68, 0xfc, 0xec, 0xf2,
	0xb4, 0xe0, 0xd5, 0x05, 0xd0, 0x0d, 0xf0, 0x90, 0xe8, 0x37, 0xcc, 0x7e, 0xa9, 0xfb, 0x0e, 0xf7,
	0x33, 0x70, 0x54, 0x42, 0xde, 0x8a, 0x30, 0x2a, 0x85, 0x5a, 0xea, 0xc0, 0xfb, 0x1a, 0xb6, 0xb2,
	0xd1, 0x7e, 0x92, 0x44, 0xcb, 0xf7, 0x48, 0x63, 0x1b, 0x3a, 0x4c, 0x9b, 0x95, 0xd2, 0xf5, 0xbe,
	0x86, 0x3b, 0x65, 0x54, 0xf2, 0x41, 0xa1, 0x3f, 0x5d, 0x09, 0x7d, 0x7f, 0x3d, 0x74, 0x11, 0xcc,
	0xfb, 0x25, 0x38, 0x23, 0x31, 0xd5, 0x68, 0x14, 0xc6, 0x5a, 0x0a, 0x45, 0x1f, 0xb2, 0xf2, 0x06,
	0x99, 0x17, 0x41, 0x6d, 0xa5, 0xfb, 0xd4, 0x6f, 0xe9, 0x3e, 0x46, 0xa5, 0x36, 0xf1, 0x32, 0x86,
	0x9e, 0xb9, 0x55, 0x32, 0x21, 0xad, 0x5d, 0x29, 0x45, 0x18, 0xba, 0x52, 0xc6, 0xcf, 0x4d, 0x98,
	0xb5, 0xfb, 0x83, 0x74, 0xe5, 0x7d, 0x0f, 0x7a, 0x27, 0x6f, 0xf9, 0x13, 0x21, 0x82, 0x54, 0xc3,
	0x5d, 0x69, 0xcf, 0x85, 0x04, 0xb3, 0x06, 0xfd, 0x65, 0xc5, 0x54, 0x93, 0xfa, 0x00, 0xec, 0x28,
	0x4c, 0xd5, 0xf5, 0x22, 0xad, 0x3a, 0xf4, 0x1e, 0x43, 0x7b, 0x82, 0xbe, 0xa2, 0x1d, 0x3d, 0xb0,
	0xaf, 0xe2, 0x90, 0x93, 0x7b, 0x2b, 0x1b, 0xb1, 0x2b, 0xf2, 0x4e, 0xa3, 0xa5, 0x5e, 0xab, 0x97,
	0x23, 0x76, 0x45, 0xf9, 0x5a, 0xde, 0x0f, 0xa0, 0x7f, 0x20, 0x91, 0x29, 0x9c, 0x26, 0xcc, 0xa7,
	0xea, 0xba, 0x0b, 0xbd, 0x03, 0x8c, 0x22, 0x96, 0x24, 0x63, 0x1e, 0xe0, 0x55, 0x09, 0x78, 0x2a,
	0x17, 0xe3, 0x51, 0x56, 0x42, 0xde, 0xef, 0xad, 0xb5, 0x7d, 0xd4, 0xc4, 0xe9, 0xbf, 0xb9, 0x8d,
	0x6d, 0xdd, 0x93, 0xa7, 0x12, 0xfd, 0xec, 0x28, 0x56, 0x7a, 0x68, 0x81, 0xba, 0x0f, 0x4d, 0x1d,
	0xcb, 0x50, 0x46, 0x5b, 0x0e, 0x68, 0x8b, 0x7d, 0xe3, 0x96, 0x2d, 0x68, 0x1d, 0xb1, 0xe4, 0xb8,
	0x2c, 0xd1, 0xbf, 0x5a, 0xfa, 0x72, 0x48, 0x84, 0x54, 0xda, 0xd5, 0x33, 0xc1, 0x02, 0x62, 0x97,
	0xc0, 0x66, 0x40, 0xb6, 0xa0, 0x95, 0x1a, 0x64, 0x59, 0x03, 0xf8, 0x0a, 0xda, 0x3e, 0x46, 0x51,
	0x24, 0x58, 0x60, 0x94, 0xf1, 0xdd, 0x6a, 0xa4, 0xaa, 0xaf, 0x87, 0x07, 0xc6, 0xf0, 0x90, 0x2b,
	0xb9, 0x24, 0x57, 0x72, 0xa1, 0x17, 0xb2, 0x76, 0xf1, 0x8d, 0xcf, 0xc1, 0x59, 0xb5, 0xe8, 0x42,
	0xfd, 0x02, 0x97, 0x26, 0xb2, 0x03, 0x8d, 0x05, 0x8b, 0xe6, 0xe6, 0x98, 0x7f, 0x58, 0xfb, 0xca,
	0xf2, 0x5e, 0x41, 0x97, 0x52, 0xa6, 0x76, 0x7c, 0xa9, 0x7b, 0x1e, 0x72, 0x15, 0xaa, 0x65, 0x15,
	0x6d, 0x6c, 0x12, 0xcc, 0xc4, 0xb5, 0x03, 0xf5, 0x44, 0x64, 0x6f, 0xea, 0xee, 0x17, 0xdb, 0x25,
	0xd0, 0xfc, 0x31, 0x5d, 0x1c, 0x4d, 0xf6, 0xcc, 0x4e, 0xab, 0x01, 0xd4, 0xe6, 0x00, 0xab, 0x74,
	0xf4, 0xa1, 0xe9, 0x57, 0x4f, 0x61, 0x1b, 0x3a, 0x7a, 0x5c, 0x71, 0x9a, 0x63, 0x68, 0xdc, 0x80,
	0xc1, 0x7b, 0x05, 0xf7, 0x74, 0xd0, 0xc7, 0x42, 0x06, 0x28, 0xf5, 0xc3, 0x6d, 0x86, 0xe6, 0x73,
	0xa1, 0x12, 0xcd, 0x5a, 0x8b, 0x96, 0x45, 0x7f, 0x00, 0x6d, 0x7d, 0xe4, 0x21, 0x3f, 0x17, 0x26,
	0xc7, 0x0d, 0xc7, 0xee, 0xbd, 0x85, 0x7e, 0x9e, 0x55, 0xe9, 0x58, 0x24, 0x28, 0x75, 0x11, 0x59,
	0xf9, 0xb3, 0xe5, 0xf6, 0xbc, 0x4c, 0x24, 0xed, 0xe3, 0x16, 0x81, 0x15, 0xe2, 0x69, 0x10, 0x9d,
	0x7f, 0xb0, 0x60, 0x90, 0x29, 0x5d, 0xc7, 0x2f, 0x63, 0x7f, 0x10, 0xad, 0x3f, 0x82, 0xc1, 0x08,
	0x23, 0xbc, 0x1d, 0xcb, 0x5a, 0x20, 0xef, 0xd7, 0xd0, 0x9d, 0x5e, 0x84, 0x51, 0x74, 0x78, 0x7e,
	0xae, 0xdb, 0xdd, 0x36, 0x74, 0x24, 0xfa, 0x62, 0x81, 0xf2, 0x75, 0x62, 0x98, 0xeb, 0x43, 0x33,
	0x60, 0x31, 0x9b, 0xe5, 0x0f, 0xc0, 0x8f, 0xc1, 0x91, 0x18, 0xcc, 0x7d, 0x1c, 0xe1, 0x39, 0x72,
	0x3f, 0xbf, 0x28, 0x5d, 0x00, 0x16, 0x04, 0xf9, 0x9c, 0xbd, 0xda, 0xc8, 0x1a, 0xf9, 0x15, 0x7e,
	0x36, 0x3f, 0x3f, 0xa7, 0xe6, 0xd5, 0xdc, 0xad, 0xef, 0x39, 0xde, 0x08, 0x3a, 0xfb, 0x4a, 0x31,
	0xff, 0x42, 0xab, 0x5d, 0x1f, 0x91, 0x86, 0x62, 0xb0, 0x92, 0xbd, 0x62, 0x72, 0x86, 0xaa, 0x38,
	0x34, 0xfa, 0x34, 0xac, 0x97, 0xdf, 0x83, 0x74, 0xf3, 0x79, 0x31, 0xb4, 0x8e, 0xc4, 0x82, 0xfa,
	0x93, 0x91, 0xa2, 0x75, 0x53, 0x39, 0x7c, 0x02, 0xb6, 0x14, 0x8a, 0x99, 0x93, 0xd8, 0x60, 0xd0,
	0x87, 0x66, 0xaa, 0x44, 0x82, 0x01, 0x85, 0x69, 0x6b, 0x42, 0xf4, 0xfd, 0x9f, 0x2a, 0x16, 0x27,
	0xa6, 0x86, 0x7e, 0x6b, 0x01, 0xe8, 0x78, 0x2f, 0x93, 0x40, 0x5f, 0x02, 0xd7, 0x6b, 0xc8, 0x80,
	0xa8, 0xbd, 0x0f, 0x44, 0xfd, 0xfd, 0x20, 0xec, 0xeb, 0x20, 0x32, 0xe5, 0xf5, 0x00, 0x46, 0xa8,
	0xd0, 0xa7, 0x5e, 0xe4, 0xfd, 0x06, 0xba, 0x87, 0xfa, 0xfe, 0xd6, 0x83, 0x93, 0x0b, 0xcd, 0x7b,
	0xcc, 0x92, 0x82, 0xc7, 0xff, 0xbb, 0x69, 0xe4, 0x00, 0xed, 0x5b, 0x00, 0x9a, 0xe2, 0xc9, 0xd0,
	0xbc, 0x82, 0x5e, 0x26, 0x20, 0x23, 0xbb, 0xeb, 0x9c, 0xec, 0x01, 0x20, 0x59, 0xbc, 0xc8, 0x3f,
	0x25, 0xfa, 0xd5, 0x1b, 0xf7, 0xb0, 0x58, 0xd3, 0xd7, 0x65, 0x66, 0xf9, 0x9c, 0x49, 0x16, 0x67,
	0x6f, 0x83, 0xcf, 0x7e, 0x0a, 0x50, 0x31, 0x01, 0x68, 0x8e, 0x48, 0x92, 0x83, 0x8f, 0x5c, 0x07,
	0x3a, 0x93, 0x4c, 0xb1, 0x4f, 0x93, 0x81, 0xe5, 0x6e, 0x83, 0x33, 0xa9, 0xaa, 0x73, 0x50, 0x73,
	0xfb, 0x00, 0xfb, 0x85, 0x32, 0x07, 0xf5, 0xc7, 0x77, 0xff, 0xf1, 0x6e, 0xc7, 0xfa, 0xd7, 0xbb,
	0x1d, 0xeb, 0xdf, 0xef, 0x76, 0xac, 0x3f, 0xfe, 0x67, 0xe7, 0xa3, 0xff, 0xfe, 0xe5, 0x13, 0xeb,
	0xac, 0x49, 0x58, 0x1e, 0xfd, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x12, 0x99, 0x4f, 0xce, 0xee, 0x10,
	0x00, 0x00,
}
