## 工作原理

1. Zeus内置了通用RPC消息

      消息号：RPCMsgID
    
      消息体：RPCMsg
      ```go
      type RPCMsg struct {
    	  ServerType  uint8
    	  SrcEntityID uint64
    	  MethodName  string
    	  Data        []byte //proto消息参数
      }
      ```

2. Zeus在程序启动时，自动注册了通用RPC消息

      ```go
      func (def *MsgDef) InitBytesMsg() {
    	  // ...(略)...
    	  def.RegMsg(RPCMsgID, "RPCMsg", new(RPCMsg))
    	  // ...(略)...
      }
      ```

3. RPCMsg消息实现函数
    
      ```go
      // MsgProc_RPCMsg 实体间RPC调用消息处理
      func (e *Entity) MsgProc_RPCMsg(content msgdef.IMsg) {
      	msg := content.(*msgdef.RPCMsg)
      	// 从客户端收到的消息要判断要调用的服务器类型
    
      	if msg.ServerType == iserver.GetSrvInst().GetSrvType() {
      		if msg.SrcEntityID == e.GetID() || msg.SrcEntityID == 0 {
      			e.FireRPC(msg.MethodName, msg.Data)
      		} else {
      			iE, ok := e.GetRealPtr().(iserver.IEntrustedRPCCaller)
      			if ok {
      				iE.EntrustedRPC(msg)
      			}
      		}
      	} else {
      		e.Post(msg.ServerType, msg)
      	}
      }
      ```
    
      最终会调到 FireRPC 函数，该函数内部会把消息丢入消息队列中。属于 [zeus/msghandler](4-1.Zeus网络封装层介绍之msghandler包.md) 包知识。
    
      简单的说，最终Zeus会调到DoRPCMsg函数，**内部查看是否有注册了对应的回调函数，有执行之。**


## 1个疑问

**MsgProc_RPCMsg函数如何Zeus层会被调用到。**

这个《5.Entity系统》中介绍


## 使用方法

上面分析不难看出，客户端发送了一个RPC消息后，服务器唯一需要做的就2件事情：

1. 定义实现RPC回调函数

      限制条件：函数名必须RPC_开头

2. 注册RPC回调函数
    
      实现回调函数的，必须注册。使用 `IMsgHandlers.RegMsgProc` 函数，例如：
    
      ```go
      func (user *RoomUser) Init(initParam interface{}) {
        // ...(略)...
        user.RegMsgProc(&RoomUserMsgProc{user: user})
        // ...(略)...
      }
      ```
