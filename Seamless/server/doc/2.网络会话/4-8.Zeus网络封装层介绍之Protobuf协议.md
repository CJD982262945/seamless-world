## 使用范围

只在Server层

## 限制条件

依附于实体上。

**通常会在Player实体上做，表示玩家收到的protobuf消息，符合逻辑。**

详细机制，在《5.Entity系统》中介绍。


## 消息号范围


#### 客户端到服务器

消息号范围：[11000, 60000)

消息号有特殊规定：

服务     | 消息号范围
--------| ------------------
Lobby   | [11000, 11999)
Room    | [12000, 12999)
Center  | [13000, 13999)
Match   | [14000, 14999)

相关代码如下：

```go
func (p *GateUserMsgProc) MsgProc_MsgForward(content interface{}) {
	rawMsg := content.(*sess.RawMsg)

	/*
		messageID 本身在消息中只占两个字节，也就是最大范围是65565
		所以消息号的取值范围是 1 - 65565之间

		11000 以内保留，用作框架内部消息定义
		11000 - 60000 之间用来上层协议使用
	*/

	srvType := int(rawMsg.MsgID / 1000)
	if srvType <= 10 || srvType >= 60 {
		return
	}

	if err := p.user.PostRaw(uint8(srvType), rawMsg.Msg); err != nil {
		p.user.Error("MsgForward failed ", err)
	}
}
```

消息到Gateway时，会把消息号除以1000，来判断是否需要forward。

而投递给哪种服务，则根据类型：

```go
package common
const (
	// ServerTypeLobby 大厅服务器
	ServerTypeLobby = 11

	// ServerTypeRoom 场景服务器
	ServerTypeRoom = 12

	// ServerTypeCenter 中心服务器
	ServerTypeCenter = 13

	// ServerTypeMatch 匹配服务器
	ServerTypeMatch = 14
)
```


**注意：项目中消息号有TimeFire/protoFile/gen.py工具自动生成。因此请勿手动修改相关文件！详细参见下面的使用方法**


#### 服务器到客户端

不要和 Zeus中的struct协议消息号重叠就行。

目前是402开始

**注意：项目中消息号有TimeFire/protoFile/gen.py工具自动生成。因此请勿手动修改相关文件！详细参见下面的使用方法**


## 使用方法

#### 1.定义protobuf协议

TimeFire/protoFile/game.proto 中定义

通过 TimeFire/protoFile/gen.py 生成 TimeFire/server/src/protoMsg/game.pb.go


#### 2.定义消息号

TimeFire/protoFile/gen.py 根据 TimeFire/protoFile/game.proto 和 TimeFire/protoFile/route，自动生成下列文件：

  - TimeFire/server/res/config/proto.json
  - TimeFire/server/src/common/protoMap.go

需要关注的是 TimeFire/protoFile/route 文件

**C->S 的协议，需要在该文件中，表明要投递给哪个服务**

目前有如下协议：
```
GunReformReq = 12;
GunReformUnequipReq = 12;
ShootReq = 12;
ChangeBulletReq = 12;
UseObjectReq = 12;
SummonAINotify = 12;
```

自动生成的TimeFire/server/src/common/protoMap.go文件代码如下：

```go
var ProtoMap = map[uint16]msgdef.IMsg{
	// ...(略)...
	12407: new(protoMsg.UseObjectReq),
	408:   new(protoMsg.RemoveObjectNotify),
	// ...(略)...
}

```

C->S：UseObjectReq 消息号为：12407

S->C：RemoveObjectNotify 消息号为：408

#### 3.实现回调函数

回调函数命名有规则，**必须以MsgProc_开头**。例如：

```go
func (p *RoomUserMsgProc) MsgProc_UseObjectReq(content interface{}) {
	msg := content.(*protoMsg.UseObjectReq)
	p.user.UseObject(msg.Thisid)
}
```

#### 4.注册回调函数

实现回调函数的，必须注册。使用 `IMsgHandlers.RegMsgProc` 函数，例如：

```go
func (user *RoomUser) Init(initParam interface{}) {
	// ...(略)...
	user.RegMsgProc(&RoomUserMsgProc{user: user})
	// ...(略)...
}
```

#### 5.S->Gateway->C回发protobuf协议

使用类似如下代码，使用Post方法：

```go
func (srv *LobbySrv) BroadcastMsg(msg msgdef.IMsg) {
	log.Info("BroadcastMsg ", msg)

	srv.TravsalEntity("Player", func(o iserver.IEntity) {
		o.Post(iserver.ServerTypeClient, msg)
	})
}
```

又如：

```go
proxy := entity.NewEntityProxy(srvID, spaceID, entityID)
proxy.Post(iserver.ServerTypeClient, xxx)
```


## 哪些服务支持protobuf协议

有注册Player实体的服务都可以：

  - Lobby
  - Room
  - Match

**Center上目前没有注册任何实体，因此客户端protobuf协议是无法forward它上面的。**
