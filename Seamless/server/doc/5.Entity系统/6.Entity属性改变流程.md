## 改变属性

例如调用：

```go
func (p *PlayerDef) SetAimPos(v *protoMsg.Vector3) {
	p.ip.SetProp("AimPos", v)
}
```

来看看背后做了什么操作。

```go
func (e *Entity) SetProp(name string, v interface{}) {
	p := e.props[name]
	// ...(略)...
	p.value = v
	e.PropDirty(name)
}
func (e *Entity) PropDirty(name string) {
	p := e.props[name]

	if p.def.Sync {
		if p.syncFlag == false {
			e.dirtyPropList = append(e.dirtyPropList, p)
		}
		p.syncFlag = true
	}
	// ...(略)...
}
```

SetXXX改变属性后，并在Entity.dirtyPropList标记下本字段数据已脏。


## 每帧同步数据

```go
func (e *Entity) OnLoop() {
	// ...(略)...
	e.ReflushDirtyProp()
	// ...(略)...
}
func (e *Entity) ReflushDirtyProp() {
	e.reflushSync()
	// ...(略)...
}
func (e *Entity) reflushSync() {
	if len(e.dirtyPropList) == 0 {
		return
	}

	for _, p := range e.dirtyPropList {
		for _, s := range p.def.InterestSrvs {
			if s != iserver.GetSrvInst().GetSrvType() && e.isEntityExisted(s) {
				m := e.getDirtyProps(s)
				e.dirtyProps[s] = append(m, p)
			}
		}

		if p.def.IsClientInterest {
			e.dirtyClientProps = append(e.dirtyClientProps, p)
			e.dirtyMRoleProps = append(e.dirtyMRoleProps, p)
		} else if p.def.IsMRoleInterest {
			e.dirtyMRoleProps = append(e.dirtyMRoleProps, p)
		}

		p.syncFlag = false
	}

	e.dirtyPropList = e.dirtyPropList[0:0]

	e.sendPropsSyncMsg()
}
```

reflushSyn函数内首先构建3种数据：

数据容器            | 说明
-------------------|--------------------------------
e.dirtyProps       | 收集改变后的数据，需要发给哪些类型服务器
e.dirtyClientProps | 收集改变后的数据，需要发给客户端的
e.dirtyMRoleProps  | 收集改变后的数据，需要发给自己的

收集完毕后，调用 sendPropsSyncMsg 发送之

## Entity.sendPropsSyncMsg

```go
func (e *Entity) sendPropsSyncMsg() {

	for s, m := range e.dirtyProps {
		if len(m) != 0 {
			if err := e.Post(s, &msgdef.PropsSync{Num: uint32(len(m)), Data: e.PackPropsToBytes(m)}); err != nil {
				e.Error("Send PropsSync failed ", err)
			}
			e.dirtyProps[s] = e.dirtyProps[s][0:0]
		}
	}

	bc, ok := e.GetRealPtr().(iserver.IClientBroadcaster)
	if len(e.dirtyClientProps) != 0 {
		msg := &msgdef.PropsSyncClient{
			EntityID: e.GetID(),
			Num:      uint32(len(e.dirtyClientProps)),
			Data:     e.PackPropsToBytes(e.dirtyClientProps),
		}
		if e.GetSpaceID() != 0 {
			if ok {
				bc.CastMsgToAllClientExceptMe(msg)
			}
		} else {
			e.PostToCell(msg)
		}
		e.dirtyClientProps = e.dirtyClientProps[0:0]
	}

	if len(e.dirtyMRoleProps) != 0 {
		msg := &msgdef.PropsSyncClient{
			EntityID: e.GetID(),
			Num:      uint32(len(e.dirtyMRoleProps)),
			Data:     e.PackPropsToBytes(e.dirtyMRoleProps),
		}
		if ok {
			bc.CastMsgToMe(msg)
		} else {
			e.Post(iserver.ServerTypeClient, msg)
		}
		e.dirtyMRoleProps = e.dirtyMRoleProps[0:0]
	}
}
```

三种类型同步数据，协议、路径略有差异：

1. 服务器间实体属性同步

	  使用的msgdef.PropsSync，直接投递之。

	  最终，目的服务器上，Entity.MsgProc_PropsSync会被调用

1. 客户端AOI关注的实体属性同步

	  如果在Room服务器，CastMsgToAllClientExceptMe。

	  即直接Room -> Client发给客户端

	  否则，调用PostToCell，先投递给Room服务器。

	  Room服务器再CastMsgToAllClient。
	  ```go
	  func (proc *EntityMsgProc) MsgProc_PropsSyncClient(content msgdef.IMsg) {
	  	msg := content.(*msgdef.PropsSyncClient)
	  	proc.e.CastMsgToAllClient(msg)
	  }
	  ```

	  即，other server -> Room -> Client

1. 自身关注的

	  两条路径：
	  - other server -> Gateway -> Client
	  - Room -> Client

## Player实体创建时，Gateway发送客户端自身关注属性

##### Gateway关注的信息

在Player.json的server字段中，并没有看到填写Gateway服务的Player实体关注什么信息：
```json
{
	"server": {
			"11": {
					"desc": "Lobby",
					"props": [
							// ...(略)...
					]
			},
			"12": {
					"desc": "Room",
					"props": [
							// ...(略)...
					]
			}
	},
}
```

这是由于，程序中，默认了Gateway关注的属性就是mrole字段的属性列表：

```go
func (def *Def) fill(jsonInfo map[string]interface{}) error {

	// ...(略)...

	for propName, propInfo := range jsonProps {
		jsonProp := propInfo.(map[string]interface{})

		// ...(略)...

		prop.IsMRoleInterest = false
		for _, mroleProp := range jsonMRole {
			if propName == mroleProp.(string) {
				prop.IsMRoleInterest = true
				prop.InterestSrvs = append(prop.InterestSrvs, iserver.ServerTypeGateway)
				break
			}
		}
	}

	return nil
}
```

所以Gateway在Player实体创建后，自然也是有 客户端自身关注的属性数据的。

##### 登录成功后，会发送这些属性列表：

```go
func (user *GateUser) onLoginSuccessFinal() {
	// ...(略)...
	user.sendMRoleProp()
}
func (user *GateUser) sendMRoleProp() {
	num, data := user.PackMRoleProps()
	msg := &msgdef.MRolePropsSyncClient{}
	msg.EntityID = user.GetID()
	msg.Num = uint32(num)
	msg.Data = data

	if sess := user.GetClientSess(); sess != nil {
		sess.Send(msg)
	} else {
		user.Error("发送主角属性失败, Sess为空")
	}
}
```
