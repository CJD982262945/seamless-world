## 一、Entity属性定义

要做持久化，首先需要确定哪些属性需要持久化。

在 res/entitydef/* .json 文件定义。属性的save=0，表示该属性不需要持久化

## 二、创建实体时的dbid参数

Zeus有3个函数可以创建实体：

  - Entities.CreateEntityAll
  - Entities.CreateEntity
  - Space.AddEntity

这3个函数都有一个参数dbid，来表明实体与数据库的管理。

即实体都有一个字段dbid（可以为0）：

```go
type Entity struct {
	// ...(略)...
	dbid         uint64
	// ...(略)...
}
```

## 三、实体被创建时，从数据库加载数据

```go
func (e *Entity) InitProp(def *Def) {
	if def == nil {
		return
	}
	// ...(略)...
	e.reflushFromDB()
}
func (e *Entity) reflushFromDB() {
	if e.dbid == 0 {
		return
	}

	var hashArgs []interface{}
	for n := range e.props {
		hashArgs = append(hashArgs, n)
	}

	if len(hashArgs) > 0 {
		values, err := dbservice.EntityUtil(e.entityType, e.dbid).GetValues(hashArgs)
		if err != nil {
			e.Error("Reflush from db failed ", err)
			return
		}

		for index, n := range hashArgs {
			info := e.props[n.(string)]
			info.UnPackValue(values[index])
		}
	}
}
```

实体创建过程中，会调用Entity.InitProp等前面都介绍过。这里略

## 每帧同步数据到数据库

```go
func (e *Entity) OnLoop() {
	// ...(略)...
	e.ReflushDirtyProp()
	// ...(略)...
}
func (e *Entity) ReflushDirtyProp() {
	// ...(略)...
	e.reflushToDB()
}
func (e *Entity) reflushToDB() {
	if e.dbid == 0 {
		return
	}

	var hashArgs []interface{}
	for n, p := range e.dirtySaveProps {
		hashArgs = append(hashArgs, n)
		hashArgs = append(hashArgs, p.PackValue())

		p.dbFlag = false
	}

	if len(hashArgs) > 0 {
		if err := dbservice.EntityUtil(e.entityType, e.dbid).SetValues(hashArgs); err != nil {
			e.Error("Reflush to db failed ", err)
		}
	}

	e.dirtySaveProps = make(map[string]*PropInfo)
}
```

## 实体销毁时，同步数据到数据库

```go
func (e *Entity) OnDestroy() {
	// ...(略)...
	e.reflushToDB()
	// ...(略)...
}
```


## zeus/dbservice/entityutil.go

通用的保存获取实体属性的redis操作类
